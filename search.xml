<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript中伪数组和数组以及转化</title>
    <url>/2020/02/17/JavaScript%E4%B8%AD%E4%BC%AA%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E8%BD%AC%E5%8C%96/</url>
    <content><![CDATA[<p>JS中伪数组与数组之间的关系<br><a id="more"></a></p>
<h2 id="JavaScript中伪数组和数组以及转化"><a href="#JavaScript中伪数组和数组以及转化" class="headerlink" title="JavaScript中伪数组和数组以及转化"></a>JavaScript中伪数组和数组以及转化</h2><p>之前看到过一个经典的面试题 说如何将伪数组转成数组 当时一脸懵逼 如今学会了高级JS然后再次看这个问题 好像没有想象中那么难。</p>
<h3 id="伪数组和数组"><a href="#伪数组和数组" class="headerlink" title="伪数组和数组"></a>伪数组和数组</h3><p>在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。</p>
<h3 id="对象与数组的关系"><a href="#对象与数组的关系" class="headerlink" title="对象与数组的关系"></a>对象与数组的关系</h3><p>首先你得确保你知道原型链以及原型得继承。</p>
<p>我们都知道所有的JS内置构造函数的对象原型都指向的是Object的原型对象(<code>Object.prototype</code>)。(也可理解为 继承自<code>Object.prototype</code>)</p>
<p>在这个前提下，可以理解为使用new Araay() 或 [ ] 创建出来的数组对象，都会拥有<code>Object.prototype</code> 的属性值。</p>
<pre><code class="lang-javascript">var obj = {};// 拥有 Object.prototype 
var arr = [];
//使用数组直接量创建的数组，由于 Array.prototype 的属性继承自 Object.prototype，
//那么，它将同时拥有 Array.prototype 和 Object.prototype
</code></pre>
<p>可以得到对象和数组的第一个区别：对象没有数组 <code>Array.prototype</code> 的属性值。</p>
<h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><p>数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码：</p>
<pre><code class="lang-javascript">var obj = {};
var arr = [];

obj[2] = &#39;a&#39;;
arr[2] = &#39;a&#39;;

console.log(obj[2]); // =&gt; a
console.log(arr[2]); // =&gt; a
console.log(obj.length); // =&gt; undefined
console.log(arr.length); // =&gt; 3
</code></pre>
<p>obj[2]输出’a’，是因为对象就是普通的键值对存取数据<br>而arr[2]输出’a’ 则不同，数组是通过索引来存取数据，arr[2]之所以输出’a’，是因为数组arr索引2的位置已经存储了数据<br><code>obj.length</code>并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined<br>而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值<br>为什么<code>arr.length</code>输出3，而不是1<br>因为在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数</p>
<h3 id="什么是伪数组"><a href="#什么是伪数组" class="headerlink" title="什么是伪数组"></a>什么是伪数组</h3><ol>
<li>拥有 length 属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)</li>
<li>不具有数组所具有的方法</li>
</ol>
<p>伪数组，就是像数组一样有 <code>length</code> 属性，也有 <code>0、1、2、3</code> 等属性的对象，看起来就像数组一样，但不是数组，比如:</p>
<pre><code class="lang-javascript">var obj = {
    0: 5,
    1: 8,
    2: 4,
    3: 6,
    lenngth:4
};
</code></pre>
<p>常见的伪数组有：</p>
<ul>
<li>函数内部的 <code>arguments</code></li>
<li>DOM 对象列表（比如通过 <code>document.getElementsByTags</code> 得到的列表）</li>
<li><code>jQuery</code> 对象（比如 <code>$(&quot;div&quot;)</code> ）</li>
</ul>
<p>伪数组是一个 Object，而真实的数组是一个 Array。</p>
<p>因为在原型链中没有<code>Array.prototype</code>这一环，所以他没有操作数组的方法<code>push,pop,shift,unshift</code>等。<code>javaScript</code>中常见的伪数组对象有以<code>nodeList</code>为原型的DOM对象，函数的参数<code>arguments</code>对象等。</p>
<p>那么有没有方法将这些伪数组对象转换成数组，从而直接使用push,pop等方法来对其进行操作呢？</p>
<p>下面我将介绍五种方法</p>
<h2 id="讲伪数组转换成数组的方法"><a href="#讲伪数组转换成数组的方法" class="headerlink" title="讲伪数组转换成数组的方法"></a>讲伪数组转换成数组的方法</h2><h3 id="ES5提供了二种方法："><a href="#ES5提供了二种方法：" class="headerlink" title="ES5提供了二种方法："></a>ES5提供了二种方法：</h3><pre><code class="lang-javascript">var obj=document.querySelectorAll(&#39;div&#39;);
// 方法1
var arr1=new Array();
arr1=arr1.__proto__.slice.call(obj);
console.log(arr1);

// 方法2
var arr2=new Array();
arr2=Array.prototype.slice.call(obj);
console.log(arr2);

// 为什么可以这样写？
// 因为实例对象的原型指向 构造函数的对象原型 也就是说 arr2.__proto__ === Array.prototype  
// 我们知道Array中有一个方法是slice(start,end) 不填就表示逐个分割 
// call改变this指向
</code></pre>
<pre><code class="lang-javascript">arrayObject.slice(start,end)
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td>必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td>end</td>
<td>可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="ES6提供了两种方法："><a href="#ES6提供了两种方法：" class="headerlink" title="ES6提供了两种方法："></a>ES6提供了两种方法：</h3><pre><code class="lang-javascript">// 方法3
var arr3=new Array();
var arr3=Array.from(obj);
console.log(arr3);

// 这里的obj是部署 Iterator 接口的数据类型，所以也可以用以下扩展运算符的方式实现转换：
// 方法4
var arr4=[...obj];
console.log(arr4);
// 如果是没有部署iterator接口的数据类型，如下面的ArrayLikeObject, 则不适用以下方法，会直接报错
// 因此这里用扩展运算符的实现中肯定用到了for of来进行遍历。

var ArrayLikeObj = {&quot;0&quot;: 1, &quot;1&quot;: 2, length: 2}
var result = [...ArrayLikeObj ]
console.log(result)  //报错
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190829161512758.png" alt="img"></p>
<h3 id="最后一种方法那就是简单粗暴"><a href="#最后一种方法那就是简单粗暴" class="headerlink" title="最后一种方法那就是简单粗暴"></a>最后一种方法那就是简单粗暴</h3><pre><code class="lang-javascript">var arr5=new Array();
for(var k in obj)
{
    arr5.push(obj[k]);
}
console.log(arr5);
</code></pre>
<h3 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h3><p>如果我们遇到的知识一个对象没有length长得怎么办呢 我们可以利用for in来做</p>
<pre><code class="lang-javascript">var obj = {
    0: 5,
    1: 8,
    2: 4,
    3: 6,
};
var arr1=new Array();
for( var k in obj)
{
    arr1.push(obj[k]);
}
console.log(arr1);
</code></pre>
]]></content>
      <categories>
        <category>javascript</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS面向对象</title>
    <url>/2020/02/16/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>关于类和对象 闭包 原型 基础值<br><a id="more"></a></p>
<h2 id="JS面向对象"><a href="#JS面向对象" class="headerlink" title="JS面向对象"></a>JS面向对象</h2><h3 id="创建类和对象-类中添加方法"><a href="#创建类和对象-类中添加方法" class="headerlink" title="创建类和对象 类中添加方法"></a>创建类和对象 类中添加方法</h3><pre><code class="lang-javascript">// 1.创建类class 创建一个 明星类
class Star{
    // 类的共有属性放到 constructor 里面
    constructor(uname,age){
        this.uname=uname;
        this.age=age;
    }
    sing(song) {
        // console.log(&#39;我唱歌&#39;);
        console.log(this.uname + song);
    }
}
// 2.利用类创建对象 new
var ldh = new Star(&#39;刘德华&#39;,18);
var zxy = new Star(&#39;张学友&#39;,20);
console.log(ldh);
console.log(zxy);
ldh.sing(&#39;冰雨&#39;);
zxy.sing(&#39;李香兰&#39;);
// (1) 类里面有个constructor 函数，可以接受传递过了的参数，同时返回实例对象
// (2) constructor 函数 只要 new 可以实例时，就会自动调用这个函数，类也会自动生成这个函数
// (3) 生成实例 new 不能忽略
// (4) 注意语法规范，创建类 类名后面不要加小括号，生成实例 类名后面加小括号，构造函数不需要加function
</code></pre>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><pre><code class="lang-javascript">//super 关键字调用父类普通函数
class Father {
    say() {
        return &#39;我是爸爸&#39;;
    }
}
class Son extends Father {
    say() {
        // console.log(&#39;我是儿子&#39;);
        console.log(super.say() + &#39;的儿子&#39;);
        // super.say() 就是调用父类中的普通函数 say()
    }
}
var son = new Son();
son.say();
// 继承中的属性或者方法查找原则: 就近原则
// 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的
// 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)
</code></pre>
<h3 id="子类继承父类加法方法-同时-扩展减法方法"><a href="#子类继承父类加法方法-同时-扩展减法方法" class="headerlink" title="子类继承父类加法方法 同时 扩展减法方法"></a>子类继承父类加法方法 同时 扩展减法方法</h3><pre><code class="lang-javascript">// 父类有加法方法
class Father {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    sum() {
        console.log(this.x + this.y);
    }
}
// 子类继承父类加法方法 同时 扩展减法方法
class Son extends Father {
    constructor(x, y) {
        // 利用super 调用父类的构造函数
        // super 必须在子类this之前调用
        super(x, y);
        this.x = x;
        this.y = y;
    }
    subtract() {
        console.log(this.x - this.y);
    }
}
var son = new Son(5, 3);
son.subtract(); // 2
son.sum(); // 8
</code></pre>
<h3 id="在编辑的方法中首先禁止选中文本使用"><a href="#在编辑的方法中首先禁止选中文本使用" class="headerlink" title="在编辑的方法中首先禁止选中文本使用"></a>在编辑的方法中首先禁止选中文本使用</h3><pre><code>window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
</code></pre><h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><h3 id="概述-创建对象的三种方法"><a href="#概述-创建对象的三种方法" class="headerlink" title="概述 创建对象的三种方法"></a>概述 创建对象的三种方法</h3><pre><code class="lang-javascript">// 1.利用 new Object 创建对象
var obj1=new Object();

// 2.利用对象字面量创建对象
var obj2={};

// 3.利用构造函数创建对象
function Star(uname,age){
    this.uname=uname;
    this.age=age;
    this.sing=function(){
        console.log(&#39;我会唱歌&#39;);
    }
}
var ldh=new Star(&#39;刘德华&#39;,18);
var zxy=new Star(&#39;张学友&#39;,19);
console.log(ldh);
ldh.sing();
zxy.sing();
</code></pre>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>构造函数</strong>是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面</p>
<p>JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。 </p>
<p><strong>静态成员</strong>：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问</p>
<p><strong>实例成员</strong>：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问</p>
<pre><code class="lang-javascript">function Star(uname,age){
    this.uname=uname;
    this.age=age;
    this.sing=function(){
        console.log(&#39;我会唱歌&#39;);
    }
}
var ldh = new Star(&#39;刘德华&#39;, 18);
// 1.实例成员就是构造函数内部通过this添加的成员 uname age sing 就是实例成员
// 实例成员只能通过实例化的对象来访问
// console.log(Star.uname); // 不可以通过构造函数来访问实例成员
// 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员
Star.sex = &#39;男&#39;;
console.log(Star.sex); // 静态成员只能通过构造函数来访问
</code></pre>
<p><strong>构造函数方法很好用，但是存在浪费内存的问题。</strong>  所以通过原型对象就可以实现方法共享</p>
<h3 id="构造函数原型-prototype"><a href="#构造函数原型-prototype" class="headerlink" title="构造函数原型 prototype"></a>构造函数原型 prototype</h3><p>JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p>
<ol>
<li><p>原型是什么 ？ </p>
<p>一个对象，我们也称为 prototype 为原型对象。</p>
</li>
<li><p>原型的作用是什么 ？ </p>
<p>共享方法</p>
</li>
</ol>
<h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 proto"></a>对象原型 <strong>proto</strong></h3><p>对象都会有一个属性 <strong>proto</strong> 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数prototype 原型对象的属性和方法，就是因为对象有 <strong>proto</strong> 原型的存在。</p>
<ul>
<li><strong>proto</strong>对象原型和原型对象 prototype 是等价的</li>
<li><strong>proto</strong>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/14/1jn16f.png" alt="1jn16f.png"></p>
<h3 id="构造函数-constructor"><a href="#构造函数-constructor" class="headerlink" title="构造函数 constructor"></a>构造函数 constructor</h3><p>对象原型（ <strong>proto</strong>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p>
<p>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p>
<p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。代码中又注释</p>
<pre><code class="lang-javascript">function Star(uname, age) {
            this.uname = uname;
            this.age = age;
        }
        // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数
        // Star.prototype.sing = function() {
        //     console.log(&#39;我会唱歌&#39;);
        // };
        // Star.prototype.movie = function() {
        //     console.log(&#39;我会演电影&#39;);
        // }
        Star.prototype = {
            // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
            constructor: Star,
            sing: function() {
                console.log(&#39;我会唱歌&#39;);
            },
            movie: function() {
                console.log(&#39;我会演电影&#39;);
            }
        }
        var ldh = new Star(&#39;刘德华&#39;, 18);
        var zxy = new Star(&#39;张学友&#39;, 19);
        console.log(Star.prototype);
        console.log(ldh.__proto__);
        console.log(Star.prototype.constructor);
        console.log(ldh.__proto__.constructor);
</code></pre>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://s2.ax1x.com/2020/02/14/1jMutJ.png" alt="1jMutJ.png"></p>
<p>前面我们说 对象原型（ <strong>proto</strong>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。 就是因为 <code>ldh.__proto__===Star.__prototype__</code> </p>
<h3 id="三者之间的总结"><a href="#三者之间的总结" class="headerlink" title="三者之间的总结"></a>三者之间的总结</h3><pre><code class="lang-tex">原型对象 prototype
es6之前我们的面向对象是通过构造函数来实现的 但是构造函数里面有个缺点 以前是把方法放到函数里面 
这样就会有一个问题 就是我们在创建对象实例的时候呢 但会为我们这个方法单独开辟内存空间来存放同一个函数（这样就比较浪费内存）
解决方案：我们把这些公共的方法定义到 我们构造函数的原型对象身上 这样就可以实现了 这个方法的共享 所有的实例都可以使用这个方法

原型是什么？
原型是一个对象 每一个构造函数都给我们定义好了这个原型对象 
原型对象的主要作用实现了方法的共享 不必再开辟内存空间 所有的实例对象都可以使用这个方法 这就是原型最伟大的地方

对象原型 __protp__
对象都会有一个属性 __proto__ 指向函数的prototype原型对象,之所以我们对象可以使用构造函数prootype原型对象的属性和方法，
就是因为对象有__proto__原型的存在 对象身上系统自己添加一个 __proto__ 指向我们的原型对象

constructor 构造函数
对象原型(__proto__)和构造函数的原型对象(prototype)里面都有一个constructor属性,constructor我们称为构造函数，因为它指向构造函数本身
constructor主要用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数。
</code></pre>
<h3 id="JavaScript-的成员查找机制-规则"><a href="#JavaScript-的成员查找机制-规则" class="headerlink" title="JavaScript 的成员查找机制(规则)"></a>JavaScript 的成员查找机制(规则)</h3><p>当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性。</p>
<p>如果没有就查找它的原型(也就是<strong>proto</strong>指向的prototype 原型对象)。</p>
<p>如果还没有就查找原型对象的原型(Object的原型对象)。</p>
<p>依次类推一直找到Object为止(null)。</p>
<p><strong>proto</strong>对象原型的意义就在于为对象成员成员查找机制提供一个方向，或者说一条路。永远指向的是构造函数的原型对象。</p>
<h3 id="原型对象this指向"><a href="#原型对象this指向" class="headerlink" title="原型对象this指向"></a>原型对象this指向</h3><p>构造函数中的this指向我们实例对象。</p>
<p>原型对象里面放的是方法，这个方法里面的this 指向的是这个方法的调用者，也就是实例对象。</p>
<h3 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h3><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p>
<pre><code class="lang-javascript">Array.prototype.sum=function(){
    let result=0;
    for(let i=0;i&lt;this.length;i++)
    {
        result+=this[i];
    }
    return result;
}
var arr=[1,2,3];
console.log(arr.sum());
</code></pre>
<p>注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>ES6之前并没有给我们提供 extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。</p>
<pre><code class="lang-javascript">// 借用父构造函数继承属性
// 1. 父构造函数
function Father(uname, age) {
    // this 指向父构造函数的对象实例
    this.uname = uname;
    this.age = age;
}
Father.prototype.money = function() {
    console.log(100000);

};
// 2 .子构造函数 
function Son(uname, age, score) {
    // this 指向子构造函数的对象实例
    Father.call(this, uname, age);
    this.score = score;
}
// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化
// 因他们共有一个内存地址 所以我们可以通过再创建一个实例对象就可以实现
Son.prototype = new Father();
// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数
Son.prototype.constructor = Son;
// 这个是子构造函数专门的方法
Son.prototype.exam = function() {
    console.log(&#39;孩子要考试&#39;);
}
var son = new Son(&#39;刘德华&#39;, 18, 100);
console.log(son);// 继承了父亲的money方法
console.log(Father.prototype);// 父构造函数中没有继承子函数专门的方法 因为他们不是同一个地址
console.log(Son.prototype.constructor);// 重新指向了自己
</code></pre>
<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><pre><code class="lang-javascript">//  函数的定义方式
// 1. 自定义函数(命名函数) 
function fn() {};

// 2. 函数表达式 (匿名函数)
var fun = function() {};

// 3. 利用 new Function(&#39;参数1&#39;,&#39;参数2&#39;, &#39;函数体&#39;);
var f = new Function(&#39;a&#39;, &#39;b&#39;, &#39;console.log(a + b)&#39;);
f(1, 2);

// 4. 所有函数都是 Function 的实例(对象)
console.dir(f);
// 5. 函数也属于对象
console.log(f instanceof Object);
</code></pre>
<h3 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h3><pre><code class="lang-javascript">// 函数的调用方式
// 1. 普通函数
function fn() {
console.log(&#39;人生的巅峰&#39;);
}
// fn();   fn.call()

// 2. 对象的方法
var o = {
    sayHi: function() {
    console.log(&#39;人生的巅峰&#39;);
    }
}
o.sayHi();

// 3. 构造函数
function Star() {};
new Star();

// 4. 绑定事件函数
btn.onclick = function() {};   // 点击了按钮就可以调用这个函数

// 5. 定时器函数
setInterval(function() {}, 1000);  这个函数是定时器自动1秒钟调用一次

// 6. 立即执行函数
(function() {
    console.log(&#39;人生的巅峰&#39;);
})();
// 立即执行函数是自动调用
</code></pre>
<h3 id="函数内this的指向"><a href="#函数内this的指向" class="headerlink" title="函数内this的指向"></a>函数内this的指向</h3><p>这些 this 的指向，是当我们调用函数的时候确定的。 调用方式的不同决定了this 的指向不同</p>
<p>一般指向我们的调用者.</p>
<p><img src="https://s2.ax1x.com/2020/02/14/1j6eHO.png" alt="1j6eHO.png"></p>
<h3 id="改变函数内部this指向"><a href="#改变函数内部this指向" class="headerlink" title="改变函数内部this指向"></a>改变函数内部this指向</h3><p>call()：当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承</p>
<p>apply()：apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</p>
<p>bind()：当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</p>
<pre><code class="lang-javascript">// call()
var o = {
     name: &#39;andy&#39;
}
function fn(a, b) {
    console.log(this);
    console.log(a + b);
};
fn.call(o, 1, 2);

// apply()
var arr = [1, 66, 3, 99, 4];
var max = Math.max.apply(Math, arr);
console.log(max); //99

var btn1 = document.querySelector(&#39;button&#39;);
btn1.onclick = function() {
    this.disabled = true; // 这个this 指向的是 btn 这个按钮
    // var that = this;
    setTimeout(function() {
        // that.disabled = false; // 定时器函数里面的this 指向的是window
         this.disabled = false; // 此时定时器函数里面的this 指向的是btn
    }.bind(this), 3000); // 这个this 指向的是btn 这个对象
}
</code></pre>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性</p>
<p>JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。</p>
<p>严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</p>
<p>严格模式对正常的 JavaScript 语义做了一些更改：</p>
<ol>
<li><p>消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。</p>
</li>
<li><p>消除代码运行的一些不安全之处，保证代码运行的安全。</p>
</li>
<li><p>提高编译器效率，增加运行速度。</p>
</li>
<li><p>禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比 </p>
</li>
</ol>
<p>如一些保留字如：class, enum, export, extends, import, super 不能做变量名</p>
<p><strong>为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句”use strict”;（或’use strict’）</strong></p>
<h3 id="严格模式下-this-指向问题"><a href="#严格模式下-this-指向问题" class="headerlink" title="严格模式下 this 指向问题"></a>严格模式下 this 指向问题</h3><ul>
<li>以前在全局作用域函数中的 this 指向 window 对象。 </li>
<li>现在严格模式下全局作用域中函数中的 this 是 undefined。 </li>
<li>以前构造函数时不加 new也可以 调用,当普通函数，this 指向全局对象</li>
<li>严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错</li>
<li>new 实例化的构造函数指向创建的对象实例。</li>
<li>定时器 this 还是指向 window </li>
<li>事件、对象还是指向调用者。</li>
</ul>
<h3 id="函数变化"><a href="#函数变化" class="headerlink" title="函数变化"></a>函数变化</h3><ul>
<li>函数不能有重名的参数。 </li>
<li>函数必须声明在顶层.新版本的 JavaScript 会引入“块级作用域”（ ES6 中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数。</li>
</ul>
<p>更多严格模式要求参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><strong>高阶函数</strong>是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p>
<pre><code class="lang-javascript">// 典型的回调函数
function fn(callback){
 callback&amp;&amp;callback();
}
fn(function(){alert(&#39;hi&#39;)}

function fn(){
 return function() {}
}
fn();
</code></pre>
<p>此时fn 就是一个高阶函数</p>
<p>函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。 最典型的就是作为回调函数。</p>
<p>同理函数也可以作为返回值传递回来</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>变量根据作用域的不同分为两种：全局变量和局部变量。当函数执行完毕，本作用域内的局部变量会销毁。</p>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包（closure）指有权访问另一个函数作用域中变量的函数。 ——- JavaScript 高级程序设计</p>
<p>简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变</p>
<pre><code>for (var i = 0; i &lt; lis.length; i++) {
    // 利用for循环创建了4个立即执行函数
    // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量
    (function(i) {
        // console.log(i);
        lis[i].onclick = function() {
        console.log(i);
        }
    })(i);
}
</code></pre><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><pre><code class="lang-javascript">// 思考题 1：
var name = &quot;The Window&quot;;
var object = {
        name: &quot;My Object&quot;,
        getNameFunc: function() {
            return function() {
                return this.name;
            };
           }
};
console.log(object.getNameFunc()())// The Window 没有用到闭包
var f = object.getNameFunc();
// 类似于
var f = function() {
    return this.name;
}
f();//相当于function(){this.name}()立即执行函数 所以返回The Window

// 思考题 2：
var name = &quot;The Window&quot;;　　
var object = {　　　　
    name: &quot;My Object&quot;,
    getNameFunc: function() {
        var that = this;
        return function() {
            return that.name;
        };
    }
};
console.log(object.getNameFunc()())// 返回My Object 用到了闭包
</code></pre>
<h3 id="闭包总结"><a href="#闭包总结" class="headerlink" title="闭包总结"></a>闭包总结</h3><p><strong>1. 闭包是什么？</strong> </p>
<p>闭包是一个函数 （一个作用域可以访问另外一个函数的局部变量）</p>
<p><strong>2. 闭包的作用是什么？</strong></p>
<p>延伸变量的作用范围</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>利用递归求:根据id返回对应的数据对象</p>
<pre><code class="lang-javascript">// 我们想要做输入id号,就可以返回的数据对象
// 1. 利用 forEach 去遍历里面的每一个对象
function getID(json, id) {
    var o = {};
    json.forEach(function(item) {
        // console.log(item); // 2个数组元素
        if (item.id == id) {
            // console.log(item);
            o = item;
            // 2. 我们想要得里层的数据 11 12 可以利用递归函数
            // 里面应该有goods这个数组并且数组的长度不为 0 
        } else if (item.goods &amp;&amp; item.goods.length &gt; 0) {
            o = getID(item.goods, id);
        }
    });
    return o;
}
console.log(getID(data, 1));
</code></pre>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：第一级被完全复制，如果第一级属性值是个对象，目标对象拷贝得到的是这个对象的引用。所以你如果只改变第一层的值 obj不会随着改变</p>
<pre><code class="lang-javascript">var obj={
    id:1,
    name:&#39;andy&#39;,
    msg:{
        age:18,
    }
};
var o={};

// for(var k in obj)
// {
//     //k是属性名 obj[k]是属性值
//     o[k]=obj[k];
// }
// console.log(o);
// o.msg.age=10;
// console.log(obj);// 浅拷贝 用的是一个内存地址 所以当我们实例对象age改变了 obj对象也改变了

//es6语法
Object.assign(o, obj); // 浅拷贝
console.log(obj);
</code></pre>
<p>深拷贝：全部都拷贝 改变自己的值不影响被拷贝对象</p>
<pre><code class="lang-javascript">var obj={
    id: 1,
    name: &#39;andy&#39;,
    msg: {
        age:18
    },
    color: [&#39;pink&#39;,&#39;purple&#39;],
    length:4
}
var o={};
function deepCopy(newobj,oldobj)
{
    for(var k in oldobj)
    {
        var item=oldobj[k];
        //判断这个值是否是数组
        if(item instanceof Array){
            newobj[k]=[];
            deepCopy(newobj[k],item)
        }else if(item instanceof Object)//判断这个是否是对象
        {
            newobj[k]={};
            deepCopy(newobj[k],item)
        }else{
            newobj[k]=item;
        }
    }
}
deepCopy(o,obj);
console.log(o);
o.msg.age=20;
console.log(obj);
</code></pre>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>这个比较简单 只要能看懂 就能自己写 就放几个案例吧</p>
<p>正则表达式案例：</p>
<pre><code class="lang-javascript">var reg1=/^abc$/; //^开头 $结尾
console.log(reg1.test(&#39;abc&#39;)); // true
console.log(reg1.test(&#39;abcd&#39;)); // false
console.log(reg1.test(&#39;aabcd&#39;)); // false
console.log(reg1.test(&#39;abcabc&#39;)); //false
</code></pre>
<pre><code class="lang-javascript">var rg=/[abc]/; // 只要包含有a 或者包含有b 或者包含有c 都返回true
console.log(rg.test(&#39;andy&#39;)); //true
console.log(rg.test(&#39;red&#39;)); //false
console.log(&#39;------------&#39;);

var rg1=/^[abc]$/; // 三选一 只有是a 或者是b 或者是c 这三个字母才返回 true
console.log(rg1.test(&#39;aa&#39;));
console.log(&#39;------------&#39;);

var reg=/^[a-z]$/; // 26个英文字母任何一个字母返回 true - 表示的是a到z的范围
console.log(reg.test(&#39;a&#39;));
console.log(reg.test(&#39;A&#39;));
console.log(&#39;------------&#39;);

// 字符组合
var reg1=/^[a-zA-Z0-9_-]$/ //任何一个字母返回true
console.log(reg1.test(&#39;ab&#39;));
console.log(reg1.test(&#39;B&#39;));
console.log(&#39;------------&#39;);
//如果中括号里面有^ 表示取反的意思 千万和我们的边界符 ^ 别混淆
var reg1=/^[^a-zA-Z0-9_-]$/
</code></pre>
<pre><code class="lang-javascript">// 量词符：用于设定某个模式出现的次数
// 简单理解：就是让下面的a这个字符重复多少次

// * 相当于 &gt;=0 可以出现0次或者很多次
var reg=/^a*$/;
console.log(reg.test(&#39;aaa&#39;));
console.log(&#39;-------------&#39;);

// + 相当于 &gt;=1 可以出现1次或者很多次
var reg0=/^a+$/;
console.log(reg0.test(&#39;a&#39;));
console.log(reg0.test(&#39;&#39;));
console.log(&#39;-------------&#39;);

// ? 相当于 1 || 0
var reg1=/^b?$/;
console.log(reg1.test(&#39;bb&#39;));//false
console.log(reg1.test(&#39;b&#39;));//true
console.log(reg1.test(&#39;&#39;));//true
console.log(&#39;-------------&#39;);
// {3} 就是重复3次
// {3,大于等于3} 就是重复3次
var reg2=/^a{3,}$/;
// {3,16} 大于等于3 并且小于等于16


// 量词是设定莫格模式出现的次数
var reg3=/^[a-zA-Z0-9_-]{6,16}$/
//这个模式用户只能输入英文字母 数字 下划线 短横线但是又边界符和[]
console.log(reg3.test(&#39;a&#39;)); //次数不符合要求
console.log(reg3.test(&#39;andy-red&#39;));//符合
console.log(reg3.test(&#39;andy!007&#39;));//格式不符合要求
</code></pre>
<p>括号总结：</p>
<pre><code class="lang-javascript">//中括号 字符集合,匹配括号中的任意字符
var reg=/^[abc]$/; // a||b||c
//大括号 量词符,里面表示重复次数
var reg=/^abc{3}$/; //它只是让c重复三次 abccc
console.log(reg.test(&#39;abc&#39;));//false
console.log(reg.test(&#39;abcabcabc&#39;));//false
console.log(reg.test(&#39;abccc&#39;));//true
// 小括号表示优先级
var reg=/^(abc){3}$/; //它是让abc重复三次
</code></pre>
<p><img src="https://s2.ax1x.com/2020/02/14/1jX79A.png" alt="1jX79A.png"><br><img src="https://s2.ax1x.com/2020/02/14/1jXohd.png" alt="1jXohd.png"></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5 ES6 基础知识</title>
    <url>/2020/02/12/ES5%20ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>一些 es5 es6的基础知识<br><a id="more"></a></p>
<h1 id="ES5语法"><a href="#ES5语法" class="headerlink" title="ES5语法"></a>ES5语法</h1><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>迭代(遍历)方法：forEach()、map()、filter()、some()、every()；</p>
<pre><code class="lang-javascript">array.forEach(function(currentValue, index, arr))
// currentValue：数组当前项的值  index：数组当前项的索引  arr：数组对象本身

var arr = [1,2,3];
var sum=0;
arr.forEach(function(value,index,array){
    console.log(&quot;每一个数组函数&quot;+value);
    console.log(&quot;每一个数组元素的索引号&quot;+index);
    console.log(&quot;数组本身&quot;+array);
    sum+=value;
})
console.log(sum);
</code></pre>
<p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组</p>
<p><strong>注意：</strong>它直接返回一个新数组</p>
<p>some() 方法用于检测数组中的元素是否满足指定条件. 通俗点 查找数组中是否有满足条件的元素</p>
<p><strong>注意</strong>：它返回值是布尔值, 如果查找到这个元素, 就返回true , 如果查找不到就返回false</p>
<pre><code class="lang-javascript">var arr=[12,66,4,88];
    var newArr=arr.filter(function(value,index,array){
    return value&gt;=20;//记得返回是一个数组
})
console.log(newArr);//Array(2)

//数组中是否有某个元素
var flag=arr.some(function(value){
    return value&gt;=20;
})
console.log(flag);//true
</code></pre>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>trim() 方法会从一个字符串的两端删除空白字符。</p>
<pre><code class="lang-javascript">//清空两边空格
var str=&quot;     andy   &quot;;
console.log(str.trim());
</code></pre>
<p>trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。</p>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><ol>
<li>Object.keys() 方法返回一个所有元素为字符串的数组。</li>
<li>Object.defineProperty() 定义新属性或修改原有的属性。<ul>
<li>value: 设置属性的值</li>
<li>writable: 值是否可以重写。true | false</li>
<li>enumerable: 目标属性是否可以被枚举。true | false</li>
<li>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false</li>
</ul>
</li>
</ol>
<pre><code class="lang-javascript">var obj={
    id: 1,
    pname:&#39;小米&#39;,
    price:1999,
    num: 2000
}
// 1.获取对象自身所有的属性 效果类型for-in
var arr=Object.keys(obj);
console.log(arr);
arr.forEach(function(value){
    console.log(value);
})
// 2.Object.defineProperty() 定义新属性或修改原有的属性
Object.defineProperty(obj,&#39;num&#39;,{
    value:1000
});
console.log(obj);
Object.defineProperty(obj,&#39;id&#39;,{
    //不允许修改
    writable:false,
});

Object.defineProperty(obj,&#39;address&#39;,{
    value:&#39;中国山东蓝翔技校xx单元&#39;,
    //不允许修改
    writable: false,
    // enumerable 如果值为false 则不允许遍历，默认的值是 false
    enumerable: false
});
</code></pre>
<h1 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h1><h3 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h3><p>ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。</p>
<p>ES6 实际上是一个泛指，泛指 ES2015 及后续的版本。</p>
<h2 id="ES6新增语法"><a href="#ES6新增语法" class="headerlink" title="ES6新增语法"></a>ES6新增语法</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>ES6中新增的用于声明变量的关键字。</p>
<ul>
<li>let声明的变量只在所处于的块级有效</li>
</ul>
<pre><code class="lang-javascript">if (true) {
    let a = 10;
}
console.log(a) // a is not defined
</code></pre>
<p>注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p>
<ul>
<li>不存在变量提升</li>
</ul>
<pre><code class="lang-javascript">console.log(a); // a is not defined 
let a = 20;
</code></pre>
<ul>
<li>暂时性死区</li>
</ul>
<pre><code class="lang-javascript">var tmp = 123;
if (true) {
 tmp = &#39;abc&#39;;// 报错 因为在这个块级作用域里面 tmp is not defined
 let tmp;
}
</code></pre>
<ul>
<li>经典面试题</li>
</ul>
<pre><code class="lang-javascript">var arr = [];
for (var i = 0; i &lt; 2; i++) {
 arr[i] = function () {
 console.log(i);
 } }
arr[0]();// 2
arr[1]();// 2
</code></pre>
<p><img src="https://s2.ax1x.com/2020/02/14/1jvLTS.png" alt="1jvLTS.png"></p>
<pre><code class="lang-javascript">let arr = [];
for (let i = 0; i &lt; 2; i++) {
 arr[i] = function () {
 console.log(i);
 } }
arr[0]();//0
arr[1]();//1
</code></pre>
<p><img src="https://s2.ax1x.com/2020/02/14/1jxfBV.png" alt="1jxfBV.png"></p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>作用：声明常量，常量就是值（内存地址）不能变化的量。</p>
<ul>
<li>具有块级作用域</li>
<li>声明常量时必须赋值</li>
<li>常量赋值后，值不能修改。<ol>
<li>基本数据类型不能更改</li>
<li>复杂数据类型数据结构内部的值能够改 不可重新赋值</li>
</ol>
</li>
</ul>
<h3 id="let、const、var-的区别"><a href="#let、const、var-的区别" class="headerlink" title="let、const、var 的区别"></a>let、const、var 的区别</h3><ol>
<li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。 </li>
<li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。 </li>
<li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值。</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/14/1vSAz9.png" alt="1vSAz9.png"></p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6中允许从数组中提取值，按照对应位置，对变量赋值。对象也可以实现解构。</p>
<h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><pre><code class="lang-javascript">let [a, b, c] = [1, 2, 3];
console.log(a);
console.log(b);
console.log(c);

// 如果解构不成功，变量的值为undefined
let [foo] = [];
let [bar, foo] = [1];
</code></pre>
<h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量。</p>
<pre><code class="lang-javascript">let person = { name: &#39;zhangsan&#39;, age: 20 };
let { name, age } = person;
console.log(name); // &#39;zhangsan&#39; 
console.log(age); // 20
</code></pre>
<pre><code class="lang-javascript">let {name: myName, age: myAge} = person; // myName myAge 属于别名
console.log(myName); // &#39;zhangsan&#39; 
console.log(myAge); // 20
</code></pre>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p>
<pre><code class="lang-javascript">function sum(num1, num2) {
    return num1 + num2;
}
const sum = (num1, num2) =&gt; num1 + num2;
</code></pre>
<p>如果形参只有一个，可以省略小括号</p>
<pre><code class="lang-javascript">function fn (v) {
    return v; 
}
const fn = v =&gt; v;
</code></pre>
<p>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this。我们可以用call 或者bind 改变指向</p>
<pre><code class="lang-javascript">const obj = { name: &#39;张三&#39;};
function fn () {
    console.log(this); //obj
    return () =&gt; {
    console.log(this); //obj
    } 
}
const resFn = fn.call(obj);
resFn();
</code></pre>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。</p>
<pre><code class="lang-javascript">function sum (first, ...args) {
 console.log(first); // 10
 console.log(args); // [20, 30] 
}
sum(10, 20, 30)
</code></pre>
<p>剩余参数和解构配合使用</p>
<pre><code class="lang-javascript">let students = [&#39;wangwu&#39;, &#39;zhangsan&#39;, &#39;lisi&#39;];
let [s1, ...s2] = students;
console.log(s1); // &#39;wangwu&#39; 
console.log(s2); // [&#39;zhangsan&#39;, &#39;lisi&#39;]
</code></pre>
<h2 id="ES6-的内置对象扩展"><a href="#ES6-的内置对象扩展" class="headerlink" title="ES6 的内置对象扩展"></a>ES6 的内置对象扩展</h2><h3 id="Array-的扩展方法"><a href="#Array-的扩展方法" class="headerlink" title="Array 的扩展方法"></a>Array 的扩展方法</h3><h4 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h4><ul>
<li>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</li>
</ul>
<pre><code class="lang-javascript">let ary = [1, 2, 3];
...ary // 1, 2, 3
console.log(...ary); // 1 2 3
console.log(1, 2, 3)
</code></pre>
<p>扩展运算符可以应用于合并数组</p>
<pre><code class="lang-javascript">let ary1=[1,2,3];
let ary2=[4,5,6];
let ary3=[...ary1,...ary2];
console.log(ary3);

//push方法
ary1.push(...ary2);
console.log(ary1);

//js方法
ary1=ary1.concat(ary2);
console.log(ary1);
</code></pre>
<ul>
<li>将类数组或可遍历对象转换为真正的数组</li>
</ul>
<pre><code class="lang-javascript">let oDivs = document.getElementsByTagName(&#39;div&#39;);
oDivs = [...oDivs];
</code></pre>
<h4 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h4><p>将类数组或可遍历对象转换为真正的数组</p>
<pre><code class="lang-javascript">let arrayLike = {
 &#39;0&#39;: &#39;a&#39;,
 &#39;1&#39;: &#39;b&#39;,
 &#39;2&#39;: &#39;c&#39;,
 length: 3
};
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code class="lang-javascript">let arrayLike = {
 &quot;0&quot;: 1,
 &quot;1&quot;: 2,
 &quot;length&quot;: 2
}
let newAry = Array.from(aryLike, item =&gt; item *2)
</code></pre>
<h4 id="实例方法：find"><a href="#实例方法：find" class="headerlink" title="实例方法：find()"></a>实例方法：find()</h4><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p>
<pre><code class="lang-javascript">let ary = [{
 id: 1,
 name: &#39;张三‘
}, {
 id: 2,
 name: &#39;李四‘
}];
let target = ary.find((item, index) =&gt; item.id == 2);
</code></pre>
<h4 id="实例方法：findIndex"><a href="#实例方法：findIndex" class="headerlink" title="实例方法：findIndex()"></a>实例方法：findIndex()</h4><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p>
<pre><code class="lang-javascript">let ary = [1, 5, 10, 15];
let index = ary.findIndex((value, index) =&gt; value &gt; 9);
console.log(index); // 2
</code></pre>
<h4 id="实例方法：includes"><a href="#实例方法：includes" class="headerlink" title="实例方法：includes()"></a>实例方法：includes()</h4><p>表示某个数组是否包含给定的值，返回布尔值</p>
<pre><code class="lang-javascript">[1, 2, 3].includes(2) // true 
[1, 2, 3].includes(4) // false
</code></pre>
<h2 id="String-的扩展方法"><a href="#String-的扩展方法" class="headerlink" title="String 的扩展方法"></a>String 的扩展方法</h2><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ul>
<li>ES6新增的创建字符串的方式，使用反引号定义。</li>
<li>模板字符串中可以解析变量。</li>
</ul>
<pre><code class="lang-javascript">let name = &#39;张三&#39;;
let sayHello = `hello,my name is ${name}`; // hello, my name is zhangsan
</code></pre>
<ul>
<li>模板字符串中可以换行</li>
</ul>
<pre><code>let result = {
 name: &#39;zhangsan&#39;,
 age: 20,
 sex: &#39;男&#39; }
let html = ` &lt;div&gt;
 &lt;span&gt;${result.name}&lt;/span&gt;
 &lt;span&gt;${result.age}&lt;/span&gt;
 &lt;span&gt;${result.sex}&lt;/span&gt;
&lt;/div&gt; `
</code></pre><ul>
<li>在模板字符串中可以调用函数。</li>
</ul>
<pre><code class="lang-javascript">const sayHello = function () {
 return &#39;哈哈哈哈 追不到我吧 我就是这么强大&#39;;
};
let greet = `${sayHello()} 哈哈哈哈`;
console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈
</code></pre>
<h3 id="实例方法：startsWith-和-endsWith"><a href="#实例方法：startsWith-和-endsWith" class="headerlink" title="实例方法：startsWith() 和 endsWith()"></a>实例方法：startsWith() 和 endsWith()</h3><ul>
<li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li>
<li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</li>
</ul>
<pre><code class="lang-javascript">let str = &#39;Hello world!&#39;;
str.startsWith(&#39;Hello&#39;) // true 
str.endsWith(&#39;!&#39;) // true
</code></pre>
<h3 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h3><p>repeat方法表示将原字符串重复n次，返回一个新字符串。</p>
<pre><code class="lang-javascript">&#39;x&#39;.repeat(3) // &quot;xxx&quot; 
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
</code></pre>
<h3 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a>Set 数据结构</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set本身是一个构造函数，用来生成 Set 数据结构。</p>
<pre><code class="lang-javascript">const s = new Set();
</code></pre>
<p>Set函数可以接受一个数组作为参数，用来初始化。</p>
<pre><code class="lang-javascript">const set = new Set([1, 2, 3, 4, 4]);
</code></pre>
<h3 id="set实例方法"><a href="#set实例方法" class="headerlink" title="set实例方法"></a>set实例方法</h3><ul>
<li>add(value)：添加某个值，返回 Set 结构本身</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li>
<li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li>
<li>clear()：清除所有成员，没有返回值</li>
</ul>
<pre><code class="lang-javascript">const s = new Set();
s.add(1).add(2).add(3); // 向 set 结构中添加值
s.delete(2) // 删除 set 结构中的2值 s.has(1) // 表示 set 结构中是否有1这个值 返回布尔值
s.clear() // 清除 set 结构中的所有值
</code></pre>
<p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p>
<pre><code class="lang-javascript">s.forEach(value =&gt; console.log(value))
</code></pre>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>this：指向最近调用function的那个东西</p>
<pre><code class="lang-javascript">{
  //es6语法
  var factory = function(){
        var _this = this;
        this.a=&#39;a&#39;;
        this.b=&#39;b&#39;;
        this.c={
            a: &#39;a+&#39;,
            b:() =&gt; {
                return this.a;
            }
          }
  }
  console.log(new factory().c.b());// a==&#39;a&#39;
};
//es5 es3语法
{
  var factory = function(){
        var _this = this;
        this.a=&#39;a&#39;;
        this.b=&#39;b&#39;;
        this.c={
                a: &#39;a+&#39;,
            b:funciton() {
            return this.a;
            }
        }
  }
  console.log(new factory().c.b());// a==&#39;a+&#39;
}
</code></pre>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><pre><code class="lang-javascript">//es6 语法
function checkParameter(){
    throw new Errror(&#39;can\&#39;t be empty&#39;)
}    
function f(x = checkParameter(),y = 7,z = 42){
    return x+y+z
}
console.log(f(1));
f();//
</code></pre>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><pre><code class="lang-javascript">//es3 es5 可变参数
function f(){
    var a=Array.prototype.slice.call(arguments);
    var sum=0;
    a.forEach(function(item){
        sum+=item*1;
    })
    return sum
}
console.log(f(1,2,3,6));

//es6 可变参数
function f(...a){
    var sum=0;
    a.forEach(item =&gt; {
        sum+=item*1
    });
    return sum
}
console.log(f(1,2,3,6));

//es5合并数组
var params=[&#39;hello&#39;,true,7];
var other=[1,2].concat[params];
console.log(other);

//es6合并数组
var params[&#39;hello&#39;,true,7];
var other=[1,2,...params];
console.log(other);
</code></pre>
<h3 id="对象代理"><a href="#对象代理" class="headerlink" title="对象代理"></a>对象代理</h3><pre><code class="lang-javascript">//es3 数据保护
var Person = function(){
    var data={
    name:&#39;es3&#39;,
    sex:&#39;male&#39;,
    age:15
    }
    this.get = function(key){
        return data[key]
    }
    this.get = function(key,value){
        if(ke!=&#39;sex&#39;)
        {
            data[key] = value
        }
    }
}
// 声明一个实例
var person = new Person();
//读取
console.table({name: person.get(&#39;name&#39;)},sex: person.get(&#39;sex&#39;));
//修改
person.set(&#39;sex&#39;,&#39;female&#39;);

//es5 数据保护
varPerson = {
    name: &#39;es5&#39;,
    age: 15
};
Object.defineProperty(Person,&#39;sex&#39;.{
    writable:false,
    value:&#39;male&#39;
});
//读取
console.table({
    name:Person.name,
    age:Person.age,
    sex:Person,sex
});
//修改
Person.sex=&#39;female&#39;;

//es6
let Person={
    name: &#39;es6&#39;,
    sex: &#39;male&#39;,
    age: 15
};
let person=new Proxy(Person,{
    get(target,key){
        return target[key]
    },
    set(target,key,value){
        if(key!==&#39;sex&#39;){
            target[key]=value;
        }
    }
});

console.table({
    name:person.name,
    age:person.age,
    sex:person,sex
});
//修改
person.sex=&#39;female&#39;;
</code></pre>
<p><img src="https://s2.ax1x.com/2020/02/01/1GZ5i4.png" alt="1GZ5i4.png"></p>
]]></content>
      <categories>
        <category>Javascript</category>
        <category>es5</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery学习</title>
    <url>/2020/02/10/jQuery%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>jQuery基础知识<br><a id="more"></a><br>[TOC]</p>
<h2 id="jQuery学习"><a href="#jQuery学习" class="headerlink" title="jQuery学习"></a>jQuery学习</h2><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>1、什么是javascript库？<br>    一个用javascript封装了很多属性和方法的文件。</p>
<p>2、javascript库有哪些？<br>    jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等</p>
<h3 id="初始jQuery"><a href="#初始jQuery" class="headerlink" title="初始jQuery"></a>初始jQuery</h3><p>jQuery的概念：jQuery是javascript实现的一个库。设计宗旨是”Write Less，Do More”,即写的少，做的多。<br>jQuery的优点：<br>    跨浏览器兼容<br>    链式编程，隐式迭代<br>    简化DOM操作，支持事件、样式、动画<br>    支持插件扩展开发<br>    开源免费</p>
<h3 id="jQuery顶级对象"><a href="#jQuery顶级对象" class="headerlink" title="jQuery顶级对象"></a>jQuery顶级对象</h3><pre><code class="lang-javascript">        // 1. $ 是jQuery的别称（另外的名字）
        // $(function() {
        //     alert(11)
        // });
        jQuery(function() {
            // alert(11)
            // $(&#39;div&#39;).hide();
            jQuery(&#39;div&#39;).hide();
        });
        // 2. $同时也是jQuery的 顶级对象
</code></pre>
<h3 id="DOM对象和jQuery对象"><a href="#DOM对象和jQuery对象" class="headerlink" title="DOM对象和jQuery对象"></a>DOM对象和jQuery对象</h3><pre><code class="lang-javascript">        // 1. DOM对象转换为 jQuery对象
        // (1) 我们直接获取视频，得到就是jQuery对象
        // $(&#39;video&#39;);
        // (2) 我们已经使用原生js 获取过来 DOM对象
        var myvideo = document.querySelector(&#39;video&#39;);
        // $(myvideo).play(); 错误 jquery里面没有play 这个方法
        // 2.  jQuery对象转换为DOM对象
        // myvideo.play();
        $(&#39;video&#39;)[0].play()
        $(&#39;video&#39;).get(0).play()
</code></pre>
<h3 id="隐式迭代（重要）"><a href="#隐式迭代（重要）" class="headerlink" title="隐式迭代（重要）"></a>隐式迭代（重要）</h3><p>遍历内部DOM（伪数组形式存储）的过程叫做隐式迭代</p>
<p>隐式迭代 就是把匹配的所有元素内部进行遍历循环  给每一个元素添加css这个方法</p>
<pre><code class="lang-javascript">// 给所有的div设置背景颜色为粉色 jQuery对象不能使用style
$(&#39;div&#39;).css(&#39;background&#39;,&#39;pink&#39;);
</code></pre>
<h3 id="jQuery-筛选选择器"><a href="#jQuery-筛选选择器" class="headerlink" title="jQuery 筛选选择器"></a>jQuery 筛选选择器</h3><p><a href="https://imgchr.com/i/1IZx0S" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/10/1IZx0S.md.png" alt="1IZx0S.md.png"></a></p>
<p><a href="https://imgchr.com/i/1IZO6P" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/10/1IZO6P.png" alt="1IZO6P.png"></a></p>
<p><a href="https://imgchr.com/i/1IZXOf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/10/1IZXOf.md.png" alt="1IZXOf.md.png"></a></p>
<p><strong>重点：</strong></p>
<p>$(“li”).parent()  | $(“ul”).children(“li”) | $(“ul”).find(“li”) | $(“.first”).siblings(“li”) | $(“li”).eq(2) </p>
<h3 id="jQuery修改样式css方法"><a href="#jQuery修改样式css方法" class="headerlink" title="jQuery修改样式css方法"></a>jQuery修改样式css方法</h3><pre><code class="lang-javascript">//获取值
var strColor=$(this).css(&#39;color&#39;);
//赋值
var strColor=$(this).css(&#39;color&#39;,&#39;red&#39;);
//赋值
$(this).css({ &quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;});
</code></pre>
<h3 id="jQuery修改样式操作类"><a href="#jQuery修改样式操作类" class="headerlink" title="jQuery修改样式操作类"></a>jQuery修改样式操作类</h3><pre><code class="lang-javascript">//添加类
$(&quot;div&quot;).addClass(&quot;current&quot;);
//删除类
$(&quot;div&quot;).removeClass(&quot;current&quot;);
//切换类
$(&quot;div&quot;).toggleClass(&quot;current&quot;);
</code></pre>
<p>👆 和DOM中的classList 里面用法类似 </p>
<h3 id="jQuery滑动效果以及事件切换"><a href="#jQuery滑动效果以及事件切换" class="headerlink" title="jQuery滑动效果以及事件切换"></a>jQuery滑动效果以及事件切换</h3><pre><code class="lang-javascript">//滑入
$(&quot;div&quot;).slideDown();
//滑出
$(&quot;div&quot;).slideUp();
//切换类
$(&quot;div&quot;).slideToggle();
</code></pre>
<h3 id="jQuery停止动画排队-在动画前面加-stop"><a href="#jQuery停止动画排队-在动画前面加-stop" class="headerlink" title="jQuery停止动画排队  在动画前面加 stop()"></a>jQuery停止动画排队  在动画前面加 stop()</h3><h3 id="jQuery淡入淡出以及突出显示案例"><a href="#jQuery淡入淡出以及突出显示案例" class="headerlink" title="jQuery淡入淡出以及突出显示案例"></a>jQuery淡入淡出以及突出显示案例</h3><pre><code class="lang-javascript">//淡入 1000-时间
$(&quot;div&quot;).fadeIn(1000)
//淡出
$(&quot;div&quot;).fadeOut(1000)
//修改透明度
$(&quot;div&quot;).fadeToggle(1000,0.5);
</code></pre>
<h3 id="jQuery自定义动画animate方法"><a href="#jQuery自定义动画animate方法" class="headerlink" title="jQuery自定义动画animate方法"></a>jQuery自定义动画animate方法</h3><pre><code>$(function() {
            $(&quot;button&quot;).click(function() {
                $(&quot;div&quot;).animate({
                    left: 500,
                    top: 300,
                    opacity: .4,
                    width: 500
                }, 500);
            })
        })
</code></pre><p><strong>$(selector).animate(styles,speed,easing,callback)</strong></p>
<p><strong>speed：规定动画的速度。默认是 “normal”。 可能的值：毫秒 （比如 1500） | “slow” | “normal” | “fast”</strong></p>
<p><strong>easing：规定在不同的动画点中设置动画速度的 easing 函数。内置的 easing 函数：swing | linear</strong></p>
<p><strong>callback：animate 函数执行完之后，要执行的函数。</strong></p>
<h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><h3 id="jQuery属性操作"><a href="#jQuery属性操作" class="headerlink" title="jQuery属性操作"></a>jQuery属性操作</h3><pre><code class="lang-javascript">// 1.普通属性和表单属性操作
// 获取值
$(&quot;a&quot;).prop(&quot;href&quot;);
// 赋值
$(&quot;input&quot;).prop(&quot;checked&quot;,true);

//2.普通属性和自定义属性操作
//获取值
$(&quot;a&quot;).attr(&quot;href&quot;);
//赋值
$(&quot;a&quot;).attr(&quot;aaa&quot;,&quot;我们都挺好&quot;);

//3.自定义属性和H5新增属性 data-list
//获取值 
$(&quot;a&quot;).data(&quot;uname&quot;);
//赋值
$(&quot;a&quot;).data(&quot;uname&quot;,&quot;哈哈哈&quot;);
</code></pre>
<h3 id="jQuery文本属性值"><a href="#jQuery文本属性值" class="headerlink" title="jQuery文本属性值"></a>jQuery文本属性值</h3><pre><code class="lang-javascript">//1.类比DOM中innerHTML属性方法：html()
//获取值
$(&quot;a&quot;).html();
//赋值
$(&quot;a&quot;).html(&quot;赋值内容，识别标签&quot;);

//2.类比DOM中innerText属性方法：text()
//获取值
$(&quot;a&quot;).text();
//赋值
$(&quot;a&quot;).text(&quot;赋值内容,NO识别标签&quot;);

//3.类比DOM中value属性方法：val()
//获取值
$(&quot;input&quot;).val();
//赋值
$(&quot;input&quot;).val(&quot;val()操作标签，必须带有value属性---表达标签&quot;);
</code></pre>
<h3 id="jQuery数据的遍历-each"><a href="#jQuery数据的遍历-each" class="headerlink" title="jQuery数据的遍历 $.each()"></a>jQuery数据的遍历 $.each()</h3><pre><code class="lang-javascript">// 1. each() 方法遍历元素
var sum = 0;
var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
$(&quot;div&quot;).each(function(i, domEle) {
        $(domEle).css(&quot;color&quot;, arr[i]);
         sum += parseInt($(domEle).text());
}

// 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据
// $.each($(&quot;div&quot;), function(i, ele) {
//     console.log(i);
//     console.log(ele);
// });
// $.each(arr, function(i, ele) {
//     console.log(i);
//     console.log(ele);
// })
$.each({
name: &quot;andy&quot;,
age: 18
}, function(i, ele) {
console.log(i); // 输出的是 name age 属性名
console.log(ele); // 输出的是 andy  18 属性值
})
</code></pre>
<h3 id="jQuery创建添加删除元素-重要"><a href="#jQuery创建添加删除元素-重要" class="headerlink" title="jQuery创建添加删除元素(重要)"></a>jQuery创建添加删除元素(重要)</h3><pre><code class="lang-javascript">//1.创建元素
$(&quot;&lt;li&gt;我是后来创建的li&lt;.li&gt;&quot;);

//2.添加元素
$(&quot;ul&quot;).append(li);      // 内部添加并且放到内容的最后面 
$(&quot;ul&quot;).prepend(li);      // 内部添加并且放到内容的最前面
$(&quot;.test&quot;).after(div);     // .test的后面兄弟形式加一个
$(&quot;.test&quot;).before(div);     // .test的前面兄弟形式加一个

//3.删除元素
$(&quot;ul&quot;).remove();      // 可以删除匹配的元素 自杀(包括自己)
$(&quot;ul&quot;).empty();     // 可以删除匹配的元素里面的子节点 孩子
$(&quot;ul&quot;).html(&quot;&quot;);     // 可以删除匹配的元素里面的子节点 孩子
</code></pre>
<h3 id="jQuery尺寸操作"><a href="#jQuery尺寸操作" class="headerlink" title="jQuery尺寸操作"></a>jQuery尺寸操作</h3><p><img src="https://s2.ax1x.com/2020/02/10/1IYNse.png" alt="1IYNse.png"></p>
<h3 id="jQuery位置操作"><a href="#jQuery位置操作" class="headerlink" title="jQuery位置操作"></a>jQuery位置操作</h3><p>1.offset() 设置或者获取偏移位置<br>    offset() 方法设置或返回被选元素相对于文档的偏移坐标，跟父级没有关系。<br>    返回值是一个对象，有2个属性 left、top ；<br>    offset().top  用于获取距离文档顶部的距离，offset().left 用于获取距离文档左侧的距离。<br>    可以设置元素的偏移：offset({ top: 10, left: 30 });</p>
<p>2.position() 获取元素偏移<br>    position() 方法用于返回被选元素相对于带有定位的父级偏移坐标<br>    返回值是一个对象，有2个属性 left、top。<br>    position().top 用于获取距离定位父级顶部的距离<br>    position().left 用于获取距离定位父级左侧的距离。如果父级都没有定位，则以文档为准。<br>    该方法只能获取</p>
<h3 id="jQuery操作元素被卷去的头部"><a href="#jQuery操作元素被卷去的头部" class="headerlink" title="jQuery操作元素被卷去的头部"></a>jQuery操作元素被卷去的头部</h3><p>1.scrollTop() 设置或者获取元素被卷去的头部<br>    scrollTop() 方法设置或返回被选元素被卷去的头部。<br>    不跟参数是获取，参数为不带单位的数字则是设置被卷去的头部</p>
<p>2.scrollLeft() 同理</p>
<h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><h3 id="jQuery事件注册"><a href="#jQuery事件注册" class="headerlink" title="jQuery事件注册"></a>jQuery事件注册</h3><pre><code class="lang-javascript">//1.on()可以一次绑定多个事件，也可以多此为同一个事件添加多个逻辑
$(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;,function(){
    $(this).toggleClass(&quot;current&quot;);
})
//2.on()可以做事件委托，就是给未来动态创建除了的子元素绑定事件
$(&quot;ol&quot;).on(&quot;click&quot;,&quot;li&quot;,function(){
    $(&quot;ol&quot;).on(&quot;click&quot;,&quot;li&quot;,function(){
        alert(11);
    })
})
</code></pre>
<h3 id="jQuery事件处理"><a href="#jQuery事件处理" class="headerlink" title="jQuery事件处理"></a>jQuery事件处理</h3><pre><code class="lang-javascript">//1.off()可以把以节绑定在某个事件上的逻辑取消
 $(&quot;div&quot;).off(&quot;click&quot;);
//2.one()可以绑定只触发一次的事件
$(&quot;ol&quot;).one(&quot;click&quot;,&quot;li&quot;,function(){
    alert(11);
})
</code></pre>
<h3 id="jQuery事件触发"><a href="#jQuery事件触发" class="headerlink" title="jQuery事件触发"></a>jQuery事件触发</h3><p>1、jQuery中的事件对象兼容性更好，获取更方便，操作几乎和DOM中的event完全一样。例如：</p>
<pre><code class="lang-javascript">$(&quot;div&quot;).on(&quot;click&quot;,function(event){
    event.stopPropagation();
    event.preventDefault();
})
</code></pre>
<h3 id="jQuery自动触发事件"><a href="#jQuery自动触发事件" class="headerlink" title="jQuery自动触发事件"></a>jQuery自动触发事件</h3><pre><code class="lang-javascript">$(&quot;div&quot;).on(&quot;click&quot;, function() {
    alert(11);
});

// 自动触发事件
// 1. 元素.事件()
// $(&quot;div&quot;).click();会触发元素的默认行为
// 2. 元素.trigger(&quot;事件&quot;)
// $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为
$(&quot;input&quot;).trigger(&quot;focus&quot;);
// 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为
$(&quot;div&quot;).triggerHandler(&quot;click&quot;);
$(&quot;input&quot;).on(&quot;focus&quot;, function() {
$(this).val(&quot;你好吗&quot;);
});
// $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);
</code></pre>
<h3 id="jQuery对象拷贝"><a href="#jQuery对象拷贝" class="headerlink" title="jQuery对象拷贝"></a>jQuery对象拷贝</h3><pre><code class="lang-javascript">var targetObj = {
    id: 0,
    msg: {
        sex: &#39;男&#39;
    }
};
var obj = {
    id: 1,
    name: &quot;andy&quot;,
    msg: {
        age: 18
    }
};
$.extend(targetObj, obj); // 会覆盖targetObj 里面原来的数据
// 1. 浅拷贝把原来对象里面的复杂数据类型地址拷贝给目标对象
targetObj.msg.age = 20;
console.log(targetObj); //结果都为20 因为拷贝的是地址
console.log(obj); //结果都为20 因为拷贝的是地址
// 2. 深拷贝把里面的数据完全复制一份给目标对象 如果里面有不冲突的属性,会合并到一起 
$.extend(true, targetObj, obj);
// console.log(targetObj); // 会覆盖targetObj 里面原来的数据
targetObj.msg.age = 20;
console.log(targetObj); // msg :{sex: &quot;男&quot;, age: 20}
console.log(obj); //不会被覆盖
</code></pre>
<h3 id="jQuery多库共存"><a href="#jQuery多库共存" class="headerlink" title="jQuery多库共存"></a>jQuery多库共存</h3><pre><code class="lang-javascript">function $(ele) {
    return document.querySelector(ele);
}
console.log($(&quot;div&quot;));
// 1. 如果$ 符号冲突 我们就使用 jQuery
jQuery.each();
// 2. 让jquery 释放对$ 控制权 让用自己决定
var suibian = jQuery.noConflict();
console.log(suibian(&quot;span&quot;));
suibian.each();
</code></pre>
<h3 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h3><p>主要有 jQuery之家 | jQuery插件库 | boostrap</p>
<p>使用插件大致步骤 （bootstrap）</p>
<p>优先引入 bootstrap.min.css、jquery.min.js、bootstrap.min.js  这三项</p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>移动web学习</title>
    <url>/2020/02/02/%E7%A7%BB%E5%8A%A8web%E5%9B%9B%E7%A7%8D%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>四种移动web布局方式<br><a id="more"></a></p>
<p>[TOC]</p>
<p>资料：<a href="https://pan.baidu.com/s/1dqaeDQNzP5FOqOTTQeKsbQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1dqaeDQNzP5FOqOTTQeKsbQ</a></p>
<h2 id="移动web开发之流式布局"><a href="#移动web开发之流式布局" class="headerlink" title="移动web开发之流式布局"></a>移动web开发之流式布局</h2><p>流式布局比较简单放两个案例自行了解</p>
<pre><code class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        *{
            margin: 0;
            padding: 0;
        }
        section{
            width: 100%;
            max-width: 980px;
            min-width: 320px;
        }
        section div{
            float: left;
            width: 50%;
            height: 400px;
        }
        section div:nth-child(1){
            background-color: pink;
        }
        section div:nth-child(2){
            background-color: purple;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;section&gt;
        &lt;div&gt;&lt;/div&gt;
        &lt;div&gt;&lt;/div&gt;
    &lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="案例：京东网页"><a href="#案例：京东网页" class="headerlink" title="案例：京东网页"></a>案例：京东网页</h3><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,user-scalable=no,maximum-scale=1.0,minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 顶部 --&gt;
    &lt;header class=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;img src=&quot;images/close.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
            &lt;li&gt;&lt;img src=&quot;images/logo.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
            &lt;li&gt;打开京东APP，购物更轻松&lt;/li&gt;
            &lt;li&gt;立即打开&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/header&gt;
    &lt;!-- 搜索 --&gt;
    &lt;div class=&quot;search-wrap&quot;&gt;
        &lt;div class=&quot;search-btn&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;search&quot;&gt;
            &lt;div class=&quot;jd-icon&quot;&gt;
            &lt;/div&gt;
            &lt;div class=&quot;sou&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;search-login&quot;&gt;登录&lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 主体内容图 --&gt;
    &lt;div class=&quot;main-content&quot;&gt;
        &lt;!-- 滑动图 --&gt;
        &lt;div class=&quot;slider&quot;&gt;
            &lt;img src=&quot;upload/banner.dpg&quot; alt=&quot;&quot;&gt;
        &lt;/div&gt;
        &lt;!-- 品牌日 --&gt;
        &lt;div class=&quot;brand&quot;&gt;
            &lt;div&gt;
                &lt;a href=&quot;&quot;&gt;
                    &lt;img src=&quot;upload/pic11.dpg&quot; alt=&quot;&quot;&gt;
                &lt;/a&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;a href=&quot;&quot;&gt;
                    &lt;img src=&quot;upload/pic22.dpg&quot; alt=&quot;&quot;&gt;
                &lt;/a&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;a href=&quot;&quot;&gt;
                    &lt;img src=&quot;upload/pic33.dpg&quot; alt=&quot;&quot;&gt;
                &lt;/a&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;nav&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;
                &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt;
                &lt;span&gt;京东超市&lt;/span&gt;
            &lt;/a&gt;
        &lt;/nav&gt;
        &lt;!-- 新闻模块 --&gt;
        &lt;div class=&quot;news&quot;&gt;
            &lt;a href=&quot;#&quot;&gt;
                &lt;img src=&quot;upload/new1.dpg&quot; alt=&quot;&quot;&gt;
            &lt;/a&gt;
            &lt;a href=&quot;#&quot;&gt;
                &lt;img src=&quot;upload/new2.dpg&quot; alt=&quot;&quot;&gt;
            &lt;/a&gt;
            &lt;a href=&quot;#&quot;&gt;
                &lt;img src=&quot;upload/new3.dpg&quot; alt=&quot;&quot;&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="index-css"><a href="#index-css" class="headerlink" title="index.css"></a>index.css</h4><pre><code class="lang-css">body{
    width: 100%;
    min-width: 320px;
    max-width: 640px;
    margin: 0 auto;
    font-size: 14px;
    line-height: 1.5;
    font-family: -apple-system,Helvetica,sans-serif;
    background-color: #ccc;
    height: 2000px;
}
/*点击高亮我们需要清除清除  设置为transparent 完成透明*/
* {
    -webkit-tap-highlight-color: transparent;
}

/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/
input {
    -webkit-appearance: none;
}

/*禁用长按页面时的弹出菜单*/
img,
a {
    -webkit-touch-callout: none;
}

ul{
    margin: 0;
    padding: 0;
    list-style: none;
}
a{
    color: #666;
    text-decoration: none;
}
img{
    vertical-align: middle;
}
.news{
    margin-top: 200px;
}
.app{
    height: 45px;
}
.app ul li{
    float: left;
    height: 45px;
    line-height: 45px;
    background-color: #333333;
    text-align: center;
    color: white;
}
.app ul li:nth-child(1){
    width: 8%;
}
.app ul li:nth-child(1) img{
    width: 10px;
}
.app ul li:nth-child(2){
    width: 10%;
}
.app ul li:nth-child(2) img{
    width: 30px;
    vertical-align: middle;
}
.app ul li:nth-child(3){
    width: 57%;
}
.app ul li:nth-child(4){
    width: 25%;
    background-color: #F63515;
}
/* 搜索 */
.search-wrap{
    position: fixed;
    height: 44px;
    width: 100%;
    overflow: hidden;
    min-width: 320px;
    max-width: 640px;
}
.search-btn{
    position: absolute;
    top: 0;
    left: 0;
    width: 40px;
    height: 44px;
}
.search-btn::before{
    content: &quot;&quot;;
    display: block;
    width: 20px;
    height: 18px;
    background: url(../images/s-btn.png) no-repeat;
    background-size: 20px 18px;
    margin: 14px 0 0 15px;
}
.search-login{
    position: absolute;
    top: 0;
    right: 0;
    width: 40px;
    height: 44px;
    line-height: 44px;
    color: #fff;
 }
.search{
    position: relative;
    height: 30px;
    background-color: #fff;
    margin: 7px 50px;
    border-radius: 15px;
} 
.jd-icon{
    width: 20px;
    height: 15px;
    position: absolute;
    top: 8px;
    left: 13px;
    background: url(../images/jd.png) no-repeat;
    background-size: 20px 15px;
}
.jd-icon::after{
    position: absolute;
    content: &quot;&quot;;
    display: block;
    right: -8px;
    top: 0;
    width: 1.5px;
    height: 15px;
    background-color: #ccc;
}
.sou{
    position: absolute;
    width: 18px;
    height: 15px;
    top: 8px;
    left: 50px;
    /* 精灵图做法 */
    background: url(../images/jd-sprites.png) no-repeat -81px 0;
    background-size: 200px auto;
}
.slider img{
    width: 100%;
}
.brand{
    overflow: hidden;
    border-radius: 10px 10px 0 0;
}
.brand div{
    width: 33.33%;
    float: left;
}
.brand div img{
    width: 100%;
}
nav{
    margin-top: 5px;
}
nav a{
    float: left;
    width: 20%;
    text-align: center;
}
nav a img{
    width: 40px;
    margin: 10px 0;
}
nav a span{
    display: block;
}
.news a{
    float: left;
    box-sizing: border-box;
}
.news img{
    width: 100%;
}
.news a:nth-child(1){
    width: 50%;
}
.news a:nth-child(n+2){
    width: 25%;
    border-left: 0.5px solid #ccc;
}
</code></pre>
<h2 id="移动web开发之flex布局"><a href="#移动web开发之flex布局" class="headerlink" title="移动web开发之flex布局"></a>移动web开发之flex布局</h2><h3 id="Flex布局原理"><a href="#Flex布局原理" class="headerlink" title="Flex布局原理"></a>Flex布局原理</h3><ul>
<li>Flex布局原理就是：给父盒子添加flex属性，来控制子盒子的位置排 列方式从而实现flex布局。</li>
<li>当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 </li>
<li>Flex布局又叫伸缩布局、弹性布局、伸缩盒布局、弹性盒布局、flex 布局</li>
</ul>
<h3 id="Flex布局父项常见属性（重点）"><a href="#Flex布局父项常见属性（重点）" class="headerlink" title="Flex布局父项常见属性（重点）"></a>Flex布局父项常见属性（重点）</h3><h4 id="1-flex设置主轴方向"><a href="#1-flex设置主轴方向" class="headerlink" title="1. flex设置主轴方向"></a>1. flex设置主轴方向</h4><ul>
<li>Flex布局中默认的主轴是row，x轴。如果想改变主轴方向可通过设置flex-direction来改变 </li>
<li><code>flex-direction:column;</code> 将主轴改为y轴，纵轴</li>
<li><code>flex-direction:row;</code> 将主轴改为x轴，横轴 </li>
<li><code>flex-direction:row- reverse;</code> 主轴为x轴，并且翻转 </li>
<li><code>flex-direction:column- reverse ;</code> 主轴为y轴，并且翻转 </li>
</ul>
<h4 id="2-开启flex布局后默认为不换行"><a href="#2-开启flex布局后默认为不换行" class="headerlink" title="2. 开启flex布局后默认为不换行"></a>2. 开启flex布局后默认为不换行</h4><ul>
<li>如果想要换行效果设置<code>flex-wrap：wrap</code></li>
</ul>
<h4 id="3-Flex-flow就是flex-direction和flex-wrap的合写"><a href="#3-Flex-flow就是flex-direction和flex-wrap的合写" class="headerlink" title="3. Flex-flow就是flex-direction和flex-wrap的合写"></a>3. Flex-flow就是flex-direction和flex-wrap的合写</h4><h4 id="4-justify-content设置主轴子元素排列形式"><a href="#4-justify-content设置主轴子元素排列形式" class="headerlink" title="4. justify-content设置主轴子元素排列形式"></a>4. justify-content设置主轴子元素排列形式</h4><ul>
<li>值为flex-start 所有子元素在主轴头部显示 </li>
<li>值为flex-end 所有子元素在主轴尾部显示</li>
<li>值为flex-center 所有子元素在主轴居中对齐 </li>
<li>值为space-around 所有子元素平分剩余空间</li>
<li>值为space-between 所有子元素先两边贴边在平分剩余空间</li>
</ul>
<h4 id="5-align-items设置侧轴子元素排列（单行）"><a href="#5-align-items设置侧轴子元素排列（单行）" class="headerlink" title="5. align-items设置侧轴子元素排列（单行）"></a>5. align-items设置侧轴子元素排列（单行）</h4><ul>
<li>利用align-items能够设置侧轴元素对齐的方式在子项为单项（单行） 的时候使用</li>
<li>align-items的值为flex-start 表示从头开始</li>
<li>align-items的值为flex-end 表示从结尾开始 </li>
<li>align-items的值为center 表示居中显示 </li>
<li>align-items的值为stretch 会将子元素拉伸</li>
</ul>
<h4 id="6-align-content设置侧轴子元素排列（多行）"><a href="#6-align-content设置侧轴子元素排列（多行）" class="headerlink" title="6. align-content设置侧轴子元素排列（多行）"></a>6. align-content设置侧轴子元素排列（多行）</h4><ul>
<li>Align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、 下对齐、居中、拉伸以及平均分配剩余空间等属 性值</li>
<li>Align-item和align-content的区别单行找 align-items  多行找 align-content</li>
</ul>
<h3 id="Flex布局子项常见属性"><a href="#Flex布局子项常见属性" class="headerlink" title="Flex布局子项常见属性"></a>Flex布局子项常见属性</h3><h4 id="1-子项flex属性使用"><a href="#1-子项flex属性使用" class="headerlink" title="1. 子项flex属性使用"></a>1. 子项flex属性使用</h4><ul>
<li>Flex用来设置分配剩余空间的比列的</li>
<li>剩余空间是指父盒子的宽度减去<strong>没有设置</strong>flex的盒子的宽度 </li>
<li>在将剩余空间按占比分配给各个子盒子 </li>
<li>比列计算：当前子盒子的flex数值/所有flex的总和</li>
</ul>
<h4 id="2-align-self和order"><a href="#2-align-self和order" class="headerlink" title="2. align-self和order"></a>2. align-self和order</h4><pre><code class="lang-css">            /* 2在1前面 默认是0 -1比0小 */
                order: -1;

            /* 3号盒子下来底侧 */
            align-self: flex-end;
</code></pre>
<p><img src="https://s2.ax1x.com/2020/02/05/1rO1qP.png" alt="1rO1qP.png"></p>
<p><strong>案例 以及 样例展示在最上面链接里面</strong></p>
<h2 id="移动web开发之rem布局"><a href="#移动web开发之rem布局" class="headerlink" title="移动web开发之rem布局"></a>移动web开发之rem布局</h2><h3 id="rem基础"><a href="#rem基础" class="headerlink" title="rem基础"></a>rem基础</h3><ul>
<li>Rem是一个相对单位，相对于html的字体大小 </li>
<li>如果整个页面很多地方用rem进行布局，只需要在不同屏幕下修改 html的字体大小，那么整个页面都会同步变化</li>
</ul>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><ul>
<li>媒体查询是css3语法，可以实现根据不同屏幕适配不同的样式 </li>
<li>语法结构为：<code>@media screen and (max-width:800px) {css样式}</code> 屏幕宽度不大于800px</li>
<li>利用媒体查询实现不同屏幕适配不同样式，发现规律可简写为判断 min-width 可以从小到大写即可 </li>
<li>原理是：利用后面会层叠前面的样式</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/05/1rOXQA.png" alt="1rOXQA.png"></p>
<h3 id="媒体查询-rem实现元素动态大小变化"><a href="#媒体查询-rem实现元素动态大小变化" class="headerlink" title="媒体查询+rem实现元素动态大小变化"></a>媒体查询+rem实现元素动态大小变化</h3><ul>
<li>Link标签利用媒体查询实现按需引入 </li>
</ul>
<h3 id="Less的使用"><a href="#Less的使用" class="headerlink" title="Less的使用"></a>Less的使用</h3><ul>
<li>首先我们选一套标准尺寸 750为准 </li>
<li>我们用屏幕尺寸（750） 除以 我们划分的份数（15） 得到了 html 里面的文字大小 （50）这个文字大小其实也就是1rem的大小 </li>
<li>因为屏幕大小不一样，但是划分的份数一样，所以最后html的文字 大小也就不一样，那么1rem在不同的屏幕下也就不一样</li>
</ul>
<pre><code class="lang-less">// 定义一个粉色的变量
@color: pink;
// 错误的变量名 @1color @color~@#
// 变量名区分大小写 @color 和Color是两种不通的变量
@font14: 14px;
body{
    background-color: @color;
}
div{
    color: @color;
    font-size: @font14;
}
// 1.less嵌套 子元素的样式直接写到父元素里面就好了
a{
    font-size: @font14;
    color: red;
    // 2.如果有伪类、交集选择器、伪元素选择器 我们内层选择器需要&amp;
    &amp;:hover{
        color: blue;
    }
}
// 3.我们运算符的左右两侧必须敲一个空格隔开
// 4.如果两个数参与运算 如果只有一个数有单位，则最后的结果就以这个单位为准
// 5.两个数参与运算，如果两个数都有单位，而且不一样的单位 最后结果以第一个为准
</code></pre>
<p><strong>案例 以及 样例展示在最上面链接里面</strong></p>
<h3 id="flexible-js技术"><a href="#flexible-js技术" class="headerlink" title="flexible.js技术"></a>flexible.js技术</h3><ul>
<li>手机淘宝团队出的简洁高效 移动端适配库</li>
<li>默认flexible是将屏幕划分10等分</li>
</ul>
<h3 id="cssrem-插件"><a href="#cssrem-插件" class="headerlink" title="cssrem 插件"></a>cssrem 插件</h3><ul>
<li>Cssrem插件会自动将px转化为rem</li>
<li>但是要注意 插件默认1rem = 16px </li>
<li>需要将插件重新配置</li>
</ul>
<p><strong>案例 以及 样例展示在最上面链接里面</strong></p>
<h2 id="移动web开发之响应式布局"><a href="#移动web开发之响应式布局" class="headerlink" title="移动web开发之响应式布局"></a>移动web开发之响应式布局</h2><p>前面都是单独制作移动端页面（主流）下面我们来看看响应式开发原理</p>
<h3 id="响应式开发原理"><a href="#响应式开发原理" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h3><ul>
<li>默认效果是在一行显示，width固定居中，所以默认将父盒子设置 width：750px，利用margin居中</li>
<li>当小于768的时候，父盒子占据一整行，并且子盒子占据三分之一 </li>
<li>所以利用媒体查询判断，如果满足条件，将父盒子width：100%； </li>
<li>将子盒子的width：33.3333%</li>
</ul>
<h3 id="Bootstrap使用"><a href="#Bootstrap使用" class="headerlink" title="Bootstrap使用"></a>Bootstrap使用</h3><p>一个很厉害的第三方库 和 前面几个创建基本文件夹一样 多一个bootstrap文件夹用来放 bootstrat资源 </p>
<ul>
<li>第一步创建基本文件夹，注意：多一个bootstrap文件夹用来放 bootstrat资源 </li>
<li>第二步下载bootstrap文件放入项目 </li>
<li>第三步将基本模板复制在html里 </li>
<li>第四步引入资源文件</li>
</ul>
<h3 id="Bootstrap使用-栅格系统"><a href="#Bootstrap使用-栅格系统" class="headerlink" title="Bootstrap使用-栅格系统"></a>Bootstrap使用-栅格系统</h3><ul>
<li>栅格系统就是默认将父元素分成12等分 </li>
<li>如果想设置子元素的宽度 </li>
<li>可根据占据的份数来决定子元素的宽度</li>
<li>例如：子元素占据3等份，那么就相当于设置子元素width：25%， </li>
<li>子元素占据4等份，那么就相当于设置子元素width：33.333%</li>
</ul>
<h3 id="Bootstrap栅格系统使用（上）"><a href="#Bootstrap栅格系统使用（上）" class="headerlink" title="Bootstrap栅格系统使用（上）"></a>Bootstrap栅格系统使用（上）</h3><ul>
<li>栅格系统是分为行和列的 </li>
<li>所以要先写行，创建一div添加类名为row即可 </li>
<li>Row下面的div为列</li>
<li>如何设置每列占多宽？</li>
<li><strong>可以通过类名 col-xs-栅格的数量(设置超小屏幕)、 col-sm-栅格的 数量(设置小屏幕)、 col-md-栅格的数量(设置中等屏幕)、 col-lg栅格的数量(设置大屏幕)</strong> </li>
<li><strong>如果列的栅格得数量加一起没有超过12咋可能出现空白并在一行显 示</strong> </li>
<li><strong>如果列的栅格数量加一起超过12，则在开始超过12的那个换行显示</strong></li>
</ul>
<h3 id="Bootstrap栅格系统使用（下）"><a href="#Bootstrap栅格系统使用（下）" class="headerlink" title="Bootstrap栅格系统使用（下）"></a>Bootstrap栅格系统使用（下）</h3><ul>
<li>列的类名可以写多个 </li>
<li>也就是可以同时设置col-xs-、 col-sm-、 col-md-、 col-lgn </li>
<li>这样的话，在不同屏幕下就会有不同的结构样式</li>
</ul>
<h3 id="Bootstrap列偏移"><a href="#Bootstrap列偏移" class="headerlink" title="Bootstrap列偏移"></a>Bootstrap列偏移</h3><ul>
<li>使用 .col-md-offset-* 类可以将列向右侧偏移。这些类实际是通过 为当前元素增加了左侧的边距（margin）。</li>
</ul>
<h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><ul>
<li>visible-lg ：设置大屏幕显示</li>
<li>hidden-lg：设置大屏幕隐藏</li>
</ul>
<h3 id="Boostrap案例"><a href="#Boostrap案例" class="headerlink" title="Boostrap案例"></a>Boostrap案例</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;!--[if lt IE 9]&gt;
      &lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt;
      &lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt;
    &lt;![endif]--&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .container:nth-child(n-1){
            margin-top: 50px;
        }
        .row&gt;div{
            height: 50px;
            background-color:pink;
        }
        span{
            font-size: 15px;
            color: #fff;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4&quot;&gt;
            &lt;!-- 我们列嵌套最好加1个行 row 这样可以取消父元素 --&gt;
            &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-md-6&quot;&gt;a&lt;/div&gt;
            &lt;div class=&quot;col-md-6&quot;&gt;b&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-md-4&quot;&gt;2&lt;/div&gt;
        &lt;div class=&quot;col-md-4&quot;&gt;3&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 两侧对齐 --&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-md-3&quot;&gt;左侧&lt;/div&gt;
            &lt;!-- 偏移的份数就是12 - 两个盒子的份数 = 6 --&gt;
            &lt;div class=&quot;col-md-3 col-md-offset-6&quot;&gt;右侧&lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 中间对齐 --&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;!-- 如果只有一个盒子 那么就偏移 = (12 - 8) /2 --&gt;
            &lt;div class=&quot;col-md-8 col-md-offset-2&quot;&gt;中间盒子&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 列排序 --&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4 col-md-push-8&quot;&gt;左侧&lt;/div&gt;
        &lt;div class=&quot;col-md-8 col-md-pull-4&quot;&gt;右侧&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 响应式工具 --&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-xs-3&quot;&gt;
                &lt;span class=&quot;visible-lg&quot;&gt;我会显示哦&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;col-xs-3&quot;&gt;2&lt;/div&gt;
            &lt;div class=&quot;col-xs-3 hidden-lg&quot;&gt;我会变魔术&lt;/div&gt;
            &lt;div class=&quot;col-xs-3&quot;&gt;4&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>案例 以及 样例展示在最上面链接里面</strong></p>
]]></content>
      <categories>
        <category>css3</category>
        <category>html5</category>
      </categories>
      <tags>
        <tag>移动web</tag>
      </tags>
  </entry>
  <entry>
    <title>Promis学习</title>
    <url>/2020/01/31/Promis%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>这是一个比较古老的技术 过短时间过学一个比较新的技术<br><a id="more"></a></p>
<h2 id="Promis简介"><a href="#Promis简介" class="headerlink" title="Promis简介"></a>Promis简介</h2><pre><code class="lang-javascript">    new Promise(
    /* 执行器 executor */
    function(resolve,reject){
    //一段时耗很长的异步操作
    resolve(); // 数据处理完成

    reject(); // 数据处理出错
    }
    )
    .then(function A(){
    //成功，下一步
    },function B(){
    //失败，做相应处理
    });
</code></pre>
<h3 id="Promise-两步执行的范例"><a href="#Promise-两步执行的范例" class="headerlink" title="Promise 两步执行的范例"></a>Promise 两步执行的范例</h3><pre><code class="lang-javascript">console.log(&#39;here we go&#39;);
    new Promise(resolve=&gt;{
        setTimeout(() =&gt; {
            resolve(&#39;hello&#39;)
        }, 2000);
    })
    .then(value=&gt;{
        console.log(value);
        return new Promise(resolve=&gt;{
            setTimeout(() =&gt; {
                resolve(&#39;world&#39;);
            }, 2000);
        });
    })
    .then(value=&gt;{
        console.log(value+&#39; world&#39;);
    })
</code></pre>
<h3 id="对已完成的Promise执行then"><a href="#对已完成的Promise执行then" class="headerlink" title="对已完成的Promise执行then"></a>对已完成的Promise执行then</h3><pre><code class="lang-javascript">console.log(&#39;start&#39;);
    let promise = new Promise(resolve=&gt;{
        setTimeout(() =&gt; {
            console.log(&#39;the promise fulfilled&#39;);
            resolve(&#39;hello,world&#39;);
        }, 1000);
    });
    setTimeout(() =&gt; {
        promise.then(value=&gt;{
            console.log(value);
        });
    }, 3000);
</code></pre>
<p>运行结果：</p>
<p><img src="https://s2.ax1x.com/2020/02/01/1G8UUI.png" alt="1G8UUI.png"></p>
<h3 id="then-里不返回-Promise-执行-then"><a href="#then-里不返回-Promise-执行-then" class="headerlink" title="then 里不返回 Promise  执行 then"></a>then 里不返回 Promise  执行 then</h3><pre><code class="lang-javascript">    new Promise(resolve =&gt; { // 执行1
    setTimeout(() =&gt; {
        resolve(&#39;hello&#39;);
    }, 1000);
    })
    .then(value =&gt; {
        console.log(value);  // 执行2
        console.log(&#39;everyone&#39;);
        (function() { // 执行5。
        //1、这段代码中没有返回新的值，下面一行返回的promise，实际是在这个函数中返回的，
        //不是在then的响应函数中返回的，then返回的promise实例就没有等待里面的这个promise完成。
        //2、一直在等待执行，等最后的then返回之后，再执行这个函数。
        //3、没有进入promise队列中，但是进程仍然是登它执行完成后才算是完成。
        return new Promise(resolve =&gt; { // 自己用自己的回调
            setTimeout(() =&gt; {
            console.log(&#39;mr&#39;);
            resolve(&#39;marry&#39;);
            }, 2000)
        });
        }());
        return false; // 执行3。1、false会直接传递到下一步，成为下一个then的value
    })
    .then(value =&gt; { // 执行4
        console.log(value + &#39;world&#39;); // value = false;
    })
</code></pre>
<p>运行结果：</p>
<p><img src="https://s2.ax1x.com/2020/02/01/1GJ30H.png" alt="1GJ30H.png"></p>
<h3 id="then-的嵌套"><a href="#then-的嵌套" class="headerlink" title=".then()的嵌套"></a>.then()的嵌套</h3><p><img src="https://img1.mukewang.com/5e16d35a00016c5a12800720.jpg" alt=""></p>
<p><img src="https://img4.mukewang.com/5bea8679000117e712800720.jpg" alt=""></p>
<p><img src="https://img1.mukewang.com/5bea87220001a4e812800720.jpg" alt=""></p>
<p><img src="https://img1.mukewang.com/5bea88af0001d2ef12800720.jpg" alt=""></p>
<p><img src="https://img.mukewang.com/5bea8ca70001faa012800720.jpg" alt=""></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>1、promise会自动捕获内部异常，并交给rejected响应函数处理。</p>
<p>2、promise试图在现有的言语框架中解决异步回调带来的问题。在栈的语言基层运行池相关的问题就无法处理了，我们能捕获到的是异步完成回调之后的这部分栈信息，仍然无法确定是哪里导致的错误。</p>
<p>3、promise执行器如果发送错误，执行器状态就会被置为rejected，fulfilled状态就不会被执行，</p>
<p><strong>错误处理的两种做法</strong></p>
<p>1、reject(‘错误信息’).then(null，message =&gt; {})；</p>
<p>2、throw new Error（’错误信息’).catch(message =&gt; {})；</p>
<p>推荐使用第二种，更加清晰好读，并且可以捕获前面的错误。</p>
<pre><code class="lang-javascript">new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
    throw new Error(&#39;bye&#39;);
  }, 1000);
})
  .then(value =&gt; {
    console.log(value + &#39;world&#39;);
  })
  .catch(error =&gt; { // 整体捕获错误的方法，可以捕获promise的错误，也可以捕获then中的错误
    console.log(&#39;Error:&#39;, error.message);
  })
</code></pre>
<h3 id="把任何异步操作包装成-promise"><a href="#把任何异步操作包装成-promise" class="headerlink" title="把任何异步操作包装成 promise"></a>把任何异步操作包装成 promise</h3><p>1、假设需求：</p>
<p>（1）用户点击按钮，弹出确认窗体。</p>
<p>（2）用户确认和取消有不同的处理。</p>
<pre><code class="lang-javascript">let confirm = popupManager.confirm(&#39;您确定么&#39;);
confirm.promise
  .then(() =&gt; {
    // do confirm staff
  })
  .catch(() =&gt; {
    // do cancel staff
  })

// 窗体的构造函数
class Confirm{
  constructor() {
    this.promise = new Promise((resolve, reject) =&gt; {
      this.confirmButton.onClick = resolve;
      this.cancelButton.onclick = reject;
    })
  }
}
</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>异步处理</tag>
      </tags>
  </entry>
  <entry>
    <title>css3学习</title>
    <url>/2020/01/30/CSS3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>关于CSS3的基础内容含样例<br><a id="more"></a><br>[TOC]</p>
<h2 id="CSS3属性学习"><a href="#CSS3属性学习" class="headerlink" title="CSS3属性学习"></a>CSS3属性学习</h2><p><img src="https://s2.ax1x.com/2020/02/02/1tgHEj.png" alt="1tgHEj.png"></p>
<h3 id="css3属性选择器"><a href="#css3属性选择器" class="headerlink" title="css3属性选择器"></a>css3属性选择器</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 选择的是：既是button 又有disabled 这个属性的元素 */
        /* 属性选择器的权重是10 */

        /* 直接写属性值 */
        button[disabled] {
            cursor: default;
        }
        button {
            cursor: pointer;
        }
        /* 属性等于值 */
        input[type=&#39;search&#39;]{
            color: pink;
        }
        /* 以某个值开头的属性值 */
        div[class^=&#39;icon&#39;]{
            color: rebeccapurple;
        }
        /* 以某个值结尾的属性值 */
        div[class$=&#39;icon&#39;]{
            color: green;
        }
        /* 可以再任意位置的 */
        div[class*=&#39;icon&#39;]{
            color: red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button&gt;1&lt;/button&gt;
    &lt;button&gt;2&lt;/button&gt;
    &lt;button disabled=&quot;disabled&quot;&gt;3&lt;/button&gt;
    &lt;button disabled=&quot;disabled&quot;&gt;4&lt;/button&gt;
    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;文本框&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;文本框&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;文本框&quot;&gt;

    &lt;input type=&quot;search&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;搜索框&quot;&gt;
    &lt;input type=&quot;search&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;搜索框&quot;&gt;
    &lt;input type=&quot;search&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;搜索框&quot;&gt;

    &lt;div class=&quot;icon1&quot;&gt;图标1&lt;/div&gt;
    &lt;div class=&quot;icon2&quot;&gt;图标2&lt;/div&gt;
    &lt;div class=&quot;icon3&quot;&gt;图标3&lt;/div&gt;
    &lt;div class=&quot;iicon4&quot;&gt;图标4&lt;/div&gt;
    &lt;div class=&quot;absicon&quot;&gt;图标5&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h3 id="css3结构伪类选择器"><a href="#css3结构伪类选择器" class="headerlink" title="css3结构伪类选择器"></a>css3结构伪类选择器</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=&lt;device-width&gt;, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 选择第一个元素 */
         ul li:first-child{
            background-color: pink;
        } 
        /* 选择第二个元素 */
        ul li:last-child{
            background-color: red;
        }
        /*  ul li:nth-child(n) 我们要第几个 n就是几 
            n可以是关键词 even偶 odd 奇 
            n可以是公式 但是n是从0开始 例如 2*n选择2,4,6... 
            不管里面的孩子是否是同一类型
        */
        ul li:nth-child(3){
            background-color: green;
        }
        /* :nth-of-type() 选择指定类型的元素 权在为1+1+10*/
        div span:nth-of-type(1){
            background-color: pink;
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;1&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
        &lt;li&gt;4&lt;/li&gt;
        &lt;li&gt;5&lt;/li&gt;
        &lt;li&gt;6&lt;/li&gt;
        &lt;li&gt;7&lt;/li&gt;
        &lt;li&gt;8&lt;/li&gt;
        &lt;li&gt;9&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div&gt;
        &lt;p&gt;我是一个屁&lt;/p&gt;
        &lt;span&gt;我是span&lt;/span&gt;
        &lt;span&gt;我是span&lt;/span&gt;
        &lt;span&gt;我是span&lt;/span&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://s2.ax1x.com/2020/02/02/1tgIKS.png" alt="1tgIKS.png"></p>
<h2 id="2D旋转-rotate"><a href="#2D旋转-rotate" class="headerlink" title="2D旋转 rotate"></a>2D旋转 rotate</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div{
            overflow: hidden;
            width: 200px;
            height: 200px;
            border:1px solid pink;
            margin: 100px auto;
        }
        div::before{
            content: &quot;黑马&quot;;
            display: block;
            width: 100%;
            height: 100%;
            background-color: hotpink;
            transform: rotate(180deg);
            /* 设置中心点 */
            transform-origin: left bottom;
            /* 过渡写到本身上，谁做动画给谁加 */
            transition: all 0.3s;
        }
        div:hover::before{
            transform: rotate(0deg);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="案例：模拟上下三角"><a href="#案例：模拟上下三角" class="headerlink" title="案例：模拟上下三角"></a>案例：模拟上下三角</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div{
            position: relative;
            width: 249px;
            height: 35px;
            border: 1px solid #000;
            transform: translate(100px,100px);
        }
        div::after{
            content: &quot;&quot;;
            position: absolute;
            top: 8px;
            right: 15px;
            width: 10px;
            height: 10px;
            border-right: 1px solid #000;
            border-bottom: 1px solid #000;
            transform: rotate(45deg);
            transition: all 0.2s;
        }
        div:hover::after{
            transform: rotate(225deg);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2D缩放-scale"><a href="#2D缩放-scale" class="headerlink" title="2D缩放 scale"></a>2D缩放 scale</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div{
            width: 100px;
            height: 100px;
            background-color: pink;
            margin: 100px auto;
            transform-origin: left bottom;
        }
        div:hover{
            /* 1.里面写的数字不跟单位 就是倍数的意思 */
            /* transform: scale(5,5); */
            /* 2.同比例缩放 同时修改宽度和高度 */
            transform: scale(2);
            /* 3.scale的优势之处不会影响其他的盒子 可以设置中心点 */
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="案例：图片放大-分页按钮案例"><a href="#案例：图片放大-分页按钮案例" class="headerlink" title="案例：图片放大 分页按钮案例"></a>案例：图片放大 分页按钮案例</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div{
            margin: 10px;
            float: left;
            overflow: hidden;
        }
        div img{
            position: relative;
            transition: all 0.4s;
        }
        div img:hover{
            transform: scale(1.1);
        }
        li{
            position:relative;
            width: 30px;
            height: 30px;
            border: 1px solid pink;
            float: left;
            margin: 10px;
            list-style: none;
            text-align: center;
            line-height: 30px;
            border-radius: 50%;
            cursor: pointer;
            transform-origin: all 0.3s;
        }
        li:hover{
            transform: scale(1.2);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;&lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;media/scale.jpg&quot;&gt;&lt;/a&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;media/scale.jpg&quot;&gt;&lt;/a&gt;
    &lt;/div&gt;
    &lt;div&gt;&lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;media/scale.jpg&quot;&gt;&lt;/a&gt;
    &lt;/div&gt;
     &lt;!-- ui&gt;li{$}*7 --&gt;
     &lt;p&gt;
    &lt;ui&gt;
        &lt;li&gt;1&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
        &lt;li&gt;4&lt;/li&gt;
        &lt;li&gt;5&lt;/li&gt;
        &lt;li&gt;6&lt;/li&gt;
        &lt;li&gt;7&lt;/li&gt;
    &lt;/ui&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2D转换综合写法顺序"><a href="#2D转换综合写法顺序" class="headerlink" title="2D转换综合写法顺序"></a>2D转换综合写法顺序</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div {
            width: 200px;
            height: 200px;
            background-color: pink;
            transition: all .5s;
        }

        div:hover {
            /* transform: rotate(180deg) translate(150px, 50px); */
            /* 我们同时有位移和其他属性，我们需要把位移放到最前面 */
            transform: translate(150px, 50px) rotate(180deg) scale(1.2);
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h3 id="css3动画基本使用"><a href="#css3动画基本使用" class="headerlink" title="css3动画基本使用"></a>css3动画基本使用</h3><p><img src="https://s2.ax1x.com/2020/02/02/1tggUA.png" alt="1tggUA.png"></p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* from和to 等价于0% 100% */
        @keyframes move {
            /* 开始动画 */
            0%{
                transform: translate(0px,0px);
            }
            /* 结束动画 */
            25%{
                transform: translate(1000px,0px);
            }
            50%{
                transform: translate(1000px,500px);
            }
            75%{
                transform: translate(0px,500px);
            }
            100%{
                transform: translate(0px,0px);
            }
        }
        div{
            width: 200px;
            height: 200px;
            background-color: pink;
            /* 动画时间 */
            animation-name: move;
            /* 持续时间 */
            animation-duration: 2s;
            /* 运动曲线 */
            animation-timing-function: ease;
            /* 何时开始 */
            animation-delay: 1s;

            /* 重复次数 iteration重复的 count次数 infinite无限 */
            /* animation-iteration-count: infinite; */

            /* 是否反方向播放 默认normal 反方向alternate*/
            /* animation-direction: alternate; */

            /* 动画结束后的状态 默认值是backwards 回到起始位置 我们可以让他停留在结束状态 forwords */
            animation-fill-mode: forwards;
            /* 动画简写属性
            animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态
            animation: name duration timing-function delay iteration-count direction fill-mode;
            animation: move 2s ease 1s infinite alternate forwards; */
        }
        div:hover{
            /* 鼠标经过div 让这个div 停止动画,鼠标离开就继续离开动画  默认running*/
            animation-play-state: paused;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="案例：大数据热点图"><a href="#案例：大数据热点图" class="headerlink" title="案例：大数据热点图"></a>案例：大数据热点图</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body{
            background-color: #333;
        }
        .map{
            position: relative;
            width: 747px;
            height: 616px;
            background: url(media/map.png) no-repeat;
            margin: 0px auto;
        }
        .city{
            position: absolute;
            top: 227px;
            right: 193px;
            color: #fff;
        }
        .tb{
            top: 500px;
            right: 80px;
        }
        .gd{
            top: 542px;
            right: 194px;
        }
        .dotted
        {
            width: 8px;
            height: 8px;
            background-color: #09f;
            border-radius: 50%;
        }
        .city div[class^=&quot;pulse&quot;]{
            /* 保证我们小波纹在父盒子里面水平垂直居中 放大之后中心向四周发散*/
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            width: 8px;
            height: 8px;
            box-shadow: 0 0 12px #009dfd;
            border-radius: 50%;
            animation: pulse 1.2s linear infinite;
        }
        .city div.pulse2{
            animation-delay: 0.4s;
        }
        .city div.pulse3{
            animation-delay: 0.8s;
        }
        @keyframes pulse {
            0%{

            }
            70%{
                /* transform: scale(5); 我们不要用scale 因为他会让 阴影变大 */
                width: 40px;
                height: 40px;
                opacity: 1;
            }
            100%{
                width: 70px;
                height: 70px;
                opacity: 0;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;map&quot;&gt;
        &lt;div class=&quot;city&quot;&gt;
            &lt;div class=&quot;dotted&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse1&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse2&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse3&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;city tb&quot;&gt;
            &lt;div class=&quot;dotted&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse1&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse2&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse3&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;city gd&quot;&gt;
            &lt;div class=&quot;dotted&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse1&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse2&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;pulse3&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="速度曲线步长-steps"><a href="#速度曲线步长-steps" class="headerlink" title="速度曲线步长 steps()"></a>速度曲线步长 steps()</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div{
            overflow: hidden;
            font-size: 20px;
            width: 0px;
            height: 30px;
            background-color: pink;
            /* 让我们的文字强制一行内显示 */
            white-space: nowrap;

            /* steps就是分几步来完成我们的动画 有了steps 就不要写 ease 或者linear 了*/
            animation: w 2s steps(8) forwards;
        }
        @keyframes w {
            0%{

            }
            100%{
                width: 160px;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;我在河南大学等你&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="案例：奔跑的熊大"><a href="#案例：奔跑的熊大" class="headerlink" title="案例：奔跑的熊大"></a>案例：奔跑的熊大</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body{
            background-color: #ccc;
        }
        div.bear{
            position: absolute;
            top: 200px;
            width: 200px;
            height: 100px;
            background: url(media/bear.png) no-repeat;
            /* animation: name duration timing-function delay iteration-count direction fill-mode; */
            animation: bear 1s steps(8) infinite backwards,move 3s forwards;
        }
        div.mountain{
            position: absolute;
            width: 1400px;
            height: 300px;
            background: url(media/bg1.png) no-repeat;
            animation: mount 10s ease-out  infinite;
        }
        @keyframes bear {
            0%{
                background-position: 0 0;
            }
            100%{
                background-position: -1600px 0;
            }
        }
        @keyframes move {
            0%{
                left: 0;
            }
            100%{
                left: 50%;
                /* margin-left: -100px; */
                transform: translateX(-50%);
            }
        }
        @keyframes mount {
            0%{
                background-position: 0 0;
            }
            100%{
                background-position: -2440px 0;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;mountain&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;bear&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3D动画"><a href="#3D动画" class="headerlink" title="3D动画"></a>3D动画</h2><p>属性基本上和2D差不多 重点<strong>左手准测</strong></p>
<h3 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body{
            /* 透视写到被观察元素的父盒子上面 */
            perspective: 200px;
        }
        div{
            width: 200px;
            height: 200px;
            background-color: pink;
            transform: translate3d(300px,100px,100px);
            /* 1.tranlateZ 后面的单位我们一般跟px */
            /* 2.translateZ(100px) 向外移动100px (向我们眼睛移动的)*/
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="3D旋转"><a href="#3D旋转" class="headerlink" title="3D旋转"></a>3D旋转</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body{
            perspective: 500px;
        }
        img{
            display: block;
            margin: 100px auto;
            transition: all 1s;
        }
        img:hover{
            /* 左手定则 拇指指向x||y||z方向 */
            /* 沿着x轴旋转 */
            /* transform: rotateX(180deg); */
            /* transform: rotate3d(1,0,0,180deg); */

            /* 沿着y轴旋转 */
            /* transform: rotateY(45deg); */
            /* transform: rotateZ(45deg); */

        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;media/pig.jpg&quot; alt=&quot;&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="3D呈现"><a href="#3D呈现" class="headerlink" title="3D呈现"></a>3D呈现</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body{
            perspective: 500px;
        }
        .box{
            position: relative;
            width: 200px;
            height: 200px;
            margin: 100px auto;
            transition: all 3s;
            /* 让子元素保持3d立体空间环境 */
            transform-style: preserve-3d;
        }
        .box:hover{
            transform: rotateY(60deg);
        }
        .box div{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: pink;
        }
        .box div:last-child{
            background-color: indigo;
            transform: rotateX(60deg);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;
        &lt;div&gt;&lt;/div&gt;
        &lt;div&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h3 id="案例：双面旋转的盒子"><a href="#案例：双面旋转的盒子" class="headerlink" title="案例：双面旋转的盒子"></a>案例：双面旋转的盒子</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body{
            perspective: 400px;
        }
        .box{
            position: relative;
            width: 300px;
            height: 300px;
            margin: 100px auto;
            transition: all .4s;
            transform-style: preserve-3d;
        }
        .box:hover{
            transform: rotateY(180deg);
        }
        .front,
        .back{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            font-size: 30px;
            color: #fff;
            text-align: center;
            line-height: 300px;
        }
        .front{
            background-color: black;
            z-index: 1;
        }
        .back{
            background-color: purple;
            transform: rotateY(180deg);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;
        &lt;div class=&quot;front&quot;&gt;河南大学&lt;/div&gt;
        &lt;div class=&quot;back&quot;&gt;陈猛&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="案例：3D导航栏"><a href="#案例：3D导航栏" class="headerlink" title="案例：3D导航栏"></a>案例：3D导航栏</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        *{
            margin: 0;
            padding: 0;
        }
        ul{
            margin: 100px;
        }
        ul li{
            perspective: 400px;
            float: left;
            display: block;
            width: 120px;
            height: 35px;
            margin: 0px 5px;
            list-style: none;
            perspective: 500px;
        }
        .box{
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: all .4s;
        }
        .box:hover{
            transform: rotateX(90deg);
        }
        .front,
        .bottom{
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            font-size: 20px;
            text-align: center;
            color: white;
            line-height: 30px;

        }
        .front{
            background-color: pink;
            z-index: 1;
            transform: translateZ(17.5px);
        }
        .bottom{
            background-color: purple;
            /* 我们如果有移动 或者其他样式，必须先写我们的移动 */
            transform:  translateY(17.5px) rotateX(-90deg);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;
            &lt;div class=&quot;box&quot;&gt;
                &lt;div class=&quot;front&quot;&gt;河南大学&lt;/div&gt;
                &lt;div class=&quot;bottom&quot;&gt;陈猛&lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;div class=&quot;box&quot;&gt;
                &lt;div class=&quot;front&quot;&gt;河南大学&lt;/div&gt;
                &lt;div class=&quot;bottom&quot;&gt;陈猛&lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;div class=&quot;box&quot;&gt;
                &lt;div class=&quot;front&quot;&gt;河南大学&lt;/div&gt;
                &lt;div class=&quot;bottom&quot;&gt;陈猛&lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="案例：3D旋转木马"><a href="#案例：3D旋转木马" class="headerlink" title="案例：3D旋转木马"></a>案例：3D旋转木马</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body{
            perspective: 1000px;
        }
        section{
            position: relative;
            width: 300px;
            height: 200px;
            margin: 150px auto;
            transform-style: preserve-3d;
            /* 添加动画 */
            animation: rotate 6s linear infinite forwards;
            background: url(media/pig.jpg);
        }
        @keyframes rotate {
            0%{

            }
            100%{
                transform: rotateY(360deg);
            }
        }
        section div{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url(media/dog.jpg) no-repeat;
        }
        section:hover{
            animation-play-state: paused;
        }
        section div:nth-child(1){
            transform: translateZ(400px);
        }
        section div:nth-child(2){
            transform: rotateY(60deg) translateZ(400px) ; 
        }
        section div:nth-child(3){
            transform: rotateY(120deg) translateZ(400px) ; 
        }
        section div:nth-child(4){
            transform: rotateY(180deg) translateZ(400px) ; 
        }
        section div:nth-child(5){
            transform: rotateY(240deg) translateZ(400px) ; 
        }
        section div:nth-child(6){
            transform: rotateY(300deg) translateZ(400px) ; 
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;section&gt;
        &lt;div&gt;&lt;/div&gt;
        &lt;div&gt;&lt;/div&gt;
        &lt;div&gt;&lt;/div&gt;
        &lt;div&gt;&lt;/div&gt;
        &lt;div&gt;&lt;/div&gt;
        &lt;div&gt;&lt;/div&gt;
    &lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="浏览器私有前缀"><a href="#浏览器私有前缀" class="headerlink" title="浏览器私有前缀"></a>浏览器私有前缀</h3><p><img src="https://s2.ax1x.com/2020/02/03/1UVXXd.png" alt="1UVXXd.png"></p>
<h2 id="总结-css3-css2"><a href="#总结-css3-css2" class="headerlink" title="总结 ( css3,css2 )"></a>总结 ( css3,css2 )</h2><h3 id="css2"><a href="#css2" class="headerlink" title="css2"></a>css2</h3><p><img src="https://s2.ax1x.com/2020/02/03/1UZh8S.png" alt="1UZh8S.png"></p>
<h3 id="css3"><a href="#css3" class="headerlink" title="css3"></a>css3</h3><p><img src="https://s2.ax1x.com/2020/02/03/1Uepr9.png" alt="1Uepr9.png"></p>
]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript高级篇</title>
    <url>/2020/01/29/JS%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<p>关于JS的详细内容<br><a id="more"></a><br>[TOC]</p>
<h2 id="JS高级篇"><a href="#JS高级篇" class="headerlink" title="JS高级篇"></a>JS高级篇</h2><h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</p>
<p>比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。</p>
<p>主要事件表：</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1KzOvq.png" alt="1KzOvq.png"></p>
<h3 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h3><p>使用JS完成一个简单的计算器功能。实现2个输入框中输入整数后，点击第三个输入框能给出2个整数的加减乘除。</p>
<p>提示：获取元素的值设置和获取方法为：例：赋值：document.getElementById(“id”）.value = 1； 取值：var = document.getElementById(“id”）.value；</p>
<p><strong>任务</strong></p>
<p>第一步： 创建构建运算函数count()。</p>
<p>第二步： 获取两个输入框中的值和获取选择框的值。</p>
<pre><code>提示：document.getElementById( id名 ).value 获取或设置 id名的值。
</code></pre><p>第三步： 获取通过下拉框来选择的值来改变加减乘除的运算法则。</p>
<pre><code>提示：使用switch判断运算法则。
</code></pre><p>第四步： 通过 = 按钮来调用创建的函数，得到结果。</p>
<p><strong>注意:</strong> 使用<code>parseInt()</code>函数可解析一个字符串,并返回一个整数。</p>
<p>代码：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt; 事件&lt;/title&gt;  
  &lt;script type=&quot;text/javascript&quot;&gt;
   function count(){
    var num1=document.getElementById(&quot;txt1&quot;).value;
    var num2=document.getElementById(&quot;txt2&quot;).value;
    var opt=document.getElementById(&quot;select&quot;).value;
    var sum=0;
    if(opt==&quot;+&quot;)
    {
      sum=parseInt(num1)+parseInt(num2);
    }
    else if(opt==&quot;-&quot;)
    sum=parseInt(num1)-parseInt(num2);
    else if(opt==&quot;*&quot;)
    sum=parseInt(num1)*parseInt(num2);
    else
    sum=parseInt(num1)/parseInt(num2); 
    document.getElementById(&quot;fruit&quot;).value=sum;
    //获取第一个输入框的值
    //获取第二个输入框的值
    //获取选择框的值
    //获取通过下拉框来选择的值来改变加减乘除的运算法则
    //设置结果输入框的值
   }
  &lt;/script&gt; 
 &lt;/head&gt; 
 &lt;body&gt;
   &lt;input type=&#39;text&#39; id=&#39;txt1&#39; /&gt; 
   &lt;select id=&#39;select&#39;&gt;
        &lt;option value=&#39;+&#39;&gt;+&lt;/option&gt;
        &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt;
        &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt;
        &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt;
   &lt;/select&gt;
   &lt;input type=&#39;text&#39; id=&#39;txt2&#39; /&gt; 
   &lt;input type=&#39;button&#39; value=&#39; = &#39; onclick=&quot;count()&quot;/&gt; &lt;!--通过 = 按钮来调用创建的函数，得到结果--&gt; 
   &lt;input type=&#39;text&#39; id=&#39;fruit&#39; /&gt;   
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="JS内置对象"><a href="#JS内置对象" class="headerlink" title="JS内置对象"></a>JS内置对象</h3><p>日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）。</p>
<p>定义一个时间对象 :</p>
<pre><code class="lang-javascript">var Udate=new Date();
</code></pre>
<p><strong>注意**</strong>:**使用关键字new，Date()的首字母必须大写。 </p>
<p>使 Udate 成为日期对象，并且已有初始值：<strong>当前时间(当前电脑系统时间)</strong>。</p>
<p>如果要自定义初始值，可以用以下方法：</p>
<pre><code class="lang-javascript">var d = new Date(2012, 10, 1);  //2012年10月1日
var d = new Date(&#39;Oct 1, 2012&#39;); //2012年10月1日
</code></pre>
<p>我们最好使用下面介绍的“方法”来严格定义时间。</p>
<p><strong>访问方法语法：</strong>“&lt;日期对象&gt;.&lt;方法&gt;”</p>
<p>Date对象中处理时间和日期的常用方法：</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1MA4rd.png" alt="1MA4rd.png"></p>
<h2 id="String-字符串对象"><a href="#String-字符串对象" class="headerlink" title="String 字符串对象"></a>String 字符串对象</h2><p>在之前的学习中已经使用字符串对象了，定义字符串的方法就是直接赋值。比如：</p>
<pre><code class="lang-javascript">var mystr = &quot;I love JavaScript!&quot;
</code></pre>
<p>定义mystr字符串后，我们就可以访问它的属性和方法。</p>
<p><strong>访问字符串对象的属性length:</strong></p>
<p>stringObject.length; 返回该字符串的长度。</p>
<pre><code class="lang-javascript">var mystr=&quot;Hello World!&quot;;
var myl=mystr.length;
</code></pre>
<p>以上代码执行后，myl 的值将是：12</p>
<p><strong>访问字符串对象的方法：</strong></p>
<p>使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写：</p>
<pre><code class="lang-javascript">var mystr=&quot;Hello world!&quot;;
var mynum=mystr.toUpperCase();
以上代码执行后，mynum 的值是：HELLO WORLD!
</code></pre>
<h3 id="返回指定位置的字符"><a href="#返回指定位置的字符" class="headerlink" title="返回指定位置的字符"></a>返回指定位置的字符</h3><p>charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。</p>
<p><strong>语法:</strong></p>
<pre><code>stringObject.charAt(index)
</code></pre><p><strong>参数说明：</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/28/1MViTI.png" alt="1MViTI.png"></p>
<p><strong>注意**</strong>：**1.字符串中第一个字符的下标是 0。最后一个字符的下标为字符串长度减一（string.length-1）。</p>
<p>2.如果参数 index 不在 0 与 string.length-1 之间，该方法将返回一个空字符串。</p>
<p><strong>如:</strong>在字符串 “I love JavaScript!” 中，返回位置2的字符：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
  var mystr=&quot;I love JavaScript!&quot;
  document.write(mystr.charAt(2));
&lt;/script&gt;
</code></pre>
<p><strong>注意：</strong>一个空格也算一个字符。</p>
<p>以上代码的运行结果：</p>
<pre><code class="lang-javascript">l
</code></pre>
<h3 id="字符串分割split"><a href="#字符串分割split" class="headerlink" title="字符串分割split()"></a>字符串分割split()</h3><p><strong>我们将按照不同的方式来分割字符串：</strong></p>
<p>使用指定符号分割字符串，代码如下:</p>
<pre><code>var mystr = &quot;www.imooc.com&quot;;
document.write(mystr.split(&quot;.&quot;)+&quot;&lt;br&gt;&quot;);
document.write(mystr.split(&quot;.&quot;, 2)+&quot;&lt;br&gt;&quot;);
</code></pre><p><strong>运行结果:</strong></p>
<pre><code>www,imooc,com
www,imooc
</code></pre><p>将字符串分割为字符，代码如下：</p>
<pre><code>document.write(mystr.split(&quot;&quot;)+&quot;&lt;br&gt;&quot;);
document.write(mystr.split(&quot;&quot;, 5));
</code></pre><p>运行结果:</p>
<pre><code>w,w,w,.,i,m,o,o,c,.,c,o,m
w,w,w,.,i
</code></pre><h3 id="返回指定字符首次出现的位置"><a href="#返回指定字符首次出现的位置" class="headerlink" title="返回指定字符首次出现的位置"></a>返回指定字符首次出现的位置</h3><p><strong>注意：</strong>1.indexOf() 方法区分大小写。</p>
<p>2.如果要检索的字符串值没有出现，则该方法返回 -1。</p>
<p>例如: 对 “I love JavaScript!” 字符串内进行不同的检索：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
  var str=&quot;I love JavaScript!&quot;
  document.write(str.indexOf(&quot;I&quot;) + &quot;&lt;br /&gt;&quot;);
  document.write(str.indexOf(&quot;v&quot;) + &quot;&lt;br /&gt;&quot;);
  document.write(str.indexOf(&quot;v&quot;,8));
&lt;/script&gt;
</code></pre>
<p>以上代码的输出：</p>
<pre><code class="lang-javascript">0
4
9
</code></pre>
<h3 id="提取字符串substring"><a href="#提取字符串substring" class="headerlink" title="提取字符串substring()"></a>提取字符串substring()</h3><p><strong>注意：</strong></p>
<p>\1. 返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。</p>
<p>\2. 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。</p>
<p>\3. 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。</p>
<p>使用 substring() 从字符串中提取字符串，代码如下：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
  var mystr=&quot;I love JavaScript&quot;;
  document.write(mystr.substring(7));
  document.write(mystr.substring(2,6));
&lt;/script&gt;
</code></pre>
<p><strong>运行结果**</strong>:**</p>
<pre><code class="lang-javascript">JavaScript
love
</code></pre>
<h3 id="提取指定数目的字符substr"><a href="#提取指定数目的字符substr" class="headerlink" title="提取指定数目的字符substr()"></a>提取指定数目的字符substr()</h3><p><strong>注意：</strong>如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</p>
<p>如果startPos为负数且绝对值大于字符串长度，startPos为0。</p>
<p>使用 substr() 从字符串中提取一些字符，代码如下：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
  var mystr=&quot;I love JavaScript!&quot;;
  document.write(mystr.substr(7));
  document.write(mystr.substr(2,4));
&lt;/script&gt;
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code class="lang-javascript">JavaScript!
love
</code></pre>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p>Math对象，提供对数据的数学计算。</p>
<p>使用 Math 的属性和方法，代码如下：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
  var mypi=Math.PI; 
  var myabs=Math.abs(-15);
  document.write(mypi);
  document.write(myabs);
&lt;/script&gt;
</code></pre>
<p><strong>运行结果**</strong>:**</p>
<pre><code class="lang-javascript">3.141592653589793
15
</code></pre>
<p><strong>注意：</strong>Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。</p>
<p>Math 对象属性</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1MZqG6.png" alt="1MZqG6.png"></p>
<p>Math 对象方法</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1MZOxO.png" alt="1MZOxO.png"></p>
<h2 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array 数组对象"></a>Array 数组对象</h2><p><strong>数组定义的方法：</strong></p>
<p>1.定义了一个空数组:</p>
<pre><code class="lang-javascript">var  数组名= new Array();
</code></pre>
<p>2.定义时指定有n个空元素的数组：</p>
<pre><code class="lang-javascript">var 数组名 =new Array(n);
</code></pre>
<p>3.定义数组的时候，直接初始化数据：</p>
<pre><code class="lang-javascript">var  数组名 = [&lt;元素1&gt;, &lt;元素2&gt;, &lt;元素3&gt;...];
</code></pre>
<p>我们定义myArray数组，并赋值，<strong>代码如下：</strong></p>
<pre><code class="lang-javascript">var myArray = [2, 8, 6];
</code></pre>
<p><strong>说明：</strong>定义了一个数组 myArray，里边的元素是：myArray[0] = 2; myArray[1] = 8; myArray[2] = 6。</p>
<p><strong>数组元素使用：</strong></p>
<pre><code class="lang-javascript">数组名[下标] = 值;
</code></pre>
<p><strong>注意</strong>: 数组的下标用方括号括起来，从0开始。</p>
<p><strong>数组属性：</strong></p>
<p>length 用法：&lt;数组对象&gt;.length；返回：数组的长度，即数组里有多少个元素。它等于数组里最后一个元素的下标加一。</p>
<p><strong>数组方法：</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/28/1MeGyF.png" alt="1MeGyF.png"></p>
<h3 id="选定元素slice"><a href="#选定元素slice" class="headerlink" title="选定元素slice()"></a>选定元素slice()</h3><p>slice() 方法可从已有的数组中返回选定的元素。</p>
<p><strong>语法</strong></p>
<pre><code>arrayObject.slice(start,end)
</code></pre><p><strong>参数说明：</strong></p>
<p><a href="http://img.mukewang.com/533299680001637b05160145.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/533299680001637b05160145.jpg" alt="img"></a></p>
<p><strong>注意：</strong></p>
<p>1.可使用负值从数组的尾部选取元素。</p>
<p>2.如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。</p>
<p>3.<code>String.slice()</code> 与 <code>Array.slice()</code> 相似。</p>
<p>我们将创建一个新数组，然后从其中选取的元素，代码如下：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
  var myarr = new Array(1,2,3,4,5,6);
  document.write(myarr + &quot;&lt;br&gt;&quot;);
  document.write(myarr.slice(2,4) + &quot;&lt;br&gt;&quot;);
  document.write(myarr);
&lt;/script&gt;
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code class="lang-javascript">1,2,3,4,5,6
3,4
1,2,3,4,5,6
</code></pre>
<h3 id="数组排序sort"><a href="#数组排序sort" class="headerlink" title="数组排序sort()"></a>数组排序sort()</h3><pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
  function sortNum(a,b) {
  return a - b;
 //升序，如降序，把“a - b”该成“b - a”
}
 var myarr = new Array(&quot;80&quot;,&quot;16&quot;,&quot;50&quot;,&quot;6&quot;,&quot;100&quot;,&quot;1&quot;);
  document.write(myarr + &quot;&lt;br&gt;&quot;);
  document.write(myarr.sort(sortNum));
&lt;/script&gt;
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code class="lang-javascript">80,16,50,6,100,1
1,6,16,50,80,100
</code></pre>
<h3 id="编程练习-1"><a href="#编程练习-1" class="headerlink" title="编程练习"></a>编程练习</h3><p>某班的成绩出来了，现在老师要把班级的成绩打印出来。</p>
<p><strong>效果图:</strong></p>
<pre><code>XXXX年XX月X日 星期X--班级总分为:81
</code></pre><p><strong>格式要求：</strong></p>
<p>1、显示打印的日期。 格式为类似“XXXX年XX月XX日 星期X” 的当前的时间。</p>
<p>2、计算出该班级的平均分（保留整数）。</p>
<p><strong>同学成绩数据如下：</strong></p>
<p>“小明:87; 小花:81; 小红:97; 小天:76;小张:74;小小:94;小西:90;小伍:76;小迪:64;小曼:76”</p>
<p><strong>任务</strong></p>
<p>第一步：可通过javascript的日期对象来得到当前的日期。</p>
<pre><code>提示:使用Date()日期对象，注意星期返回值为0-6，所以要转成文字&quot;星期X&quot;
</code></pre><p>第二步：一长窜的字符串不好弄，找规律后分割放到数组里更好操作哦。</p>
<p>第三步：分割字符串得到分数，然后求和取整。</p>
<pre><code>提示：parseInt() 字符串类型转成整型。
</code></pre><p>代码：</p>
<pre><code class="lang-javascript">&lt;!DOCTYPE  HTML&gt;
&lt;html &gt;
&lt;head&gt;
&lt;title&gt;系好安全带,准备启航&lt;/title&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

  //通过javascript的日期对象来得到当前的日期，并输出。
  var currentdate=new Date();
  var weekday = [&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;];
  document.write(
    currentdate.getFullYear()+&quot;年&quot;+(currentdate.getMonth()+1)+&quot;月&quot;+currentdate.getDate()+&quot;日&quot;+&quot; &quot;+weekday[currentdate.getDay()]
  );
  //成绩是一长窜的字符串不好处理，找规律后分割放到数组里更好操作哦
  var scoreStr = &quot;小明:87;小花:81;小红:97;小天:76;小张:74;小小:94;小西:90;小伍:76;小迪:64;小曼:76&quot;;
  var scorceArr = scoreStr.split(&quot;;&quot;);
  var sum=0;
  //从数组中将成绩撮出来，然后求和取整，并输出。
  for(var i=0;i&lt;scorceArr.length;i++)
  {
    sum+=parseInt(scorceArr[i].substr(scorceArr[i].indexOf(&quot;:&quot;)+1));
  }
  document.write(&quot;&lt;br/&gt;&quot;+&quot;班级总分为：&quot;+sum+&quot;&lt;br/&gt;&quot;);
  document.write(&quot;班级平均分&quot;+Math.floor(sum/scorceArr.length));
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>window对象是BOM的核心，window对象指当前的浏览器窗口。</p>
<p><strong>window对象方法:</strong></p>
<p><strong><a href="http://img.mukewang.com/535483720001a54506670563.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/535483720001a54506670563.jpg" alt="img"></a></strong></p>
<p><strong>注意:</strong>在JavaScript基础篇中，已讲解了部分属性，window对象重点讲解计时器。</p>
<h3 id="JavaScript-计时器"><a href="#JavaScript-计时器" class="headerlink" title="JavaScript 计时器"></a>JavaScript 计时器</h3><p>在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。<br> <strong>计时器类型：</strong><br> 一次性计时器：仅在指定的延迟时间之后触发一次。<br> 间隔性触发计时器：每隔一定的时间间隔就触发一次。<br> <strong>计时器方法：</strong></p>
<p><a href="http://img1.sycdn.imooc.com/56976e1700014fc504090143.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/56976e1700014fc504090143.jpg" alt="img"></a></p>
<h3 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h3><p>history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。</p>
<p><strong>注意:从\</strong>窗口*<em>被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。*</em></p>
<p><strong>语法：</strong></p>
<pre><code class="lang-javascript">window.history.[属性|方法]
</code></pre>
<p><strong>注意：</strong>window可以省略。</p>
<p><strong>History 对象属性</strong></p>
<p><a href="http://img1.sycdn.imooc.com/53548c030001759e05840068.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/53548c030001759e05840068.jpg" alt="img"></a></p>
<p><strong>History 对象方法</strong></p>
<p><strong><a href="http://img1.sycdn.imooc.com/53548c200001228206210123.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/53548c200001228206210123.jpg" alt="img"></a></strong></p>
<p>使用length属性，当前窗口的浏览历史总长度，<strong>代码如下：</strong></p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
  var HL = window.history.length;
  document.write(HL);
&lt;/script&gt;
</code></pre>
<h3 id="返回前一个浏览的页面"><a href="#返回前一个浏览的页面" class="headerlink" title="返回前一个浏览的页面"></a>返回前一个浏览的页面</h3><p>back()方法，加载 history 列表中的前一个 URL。</p>
<p><strong>语法：</strong></p>
<pre><code class="lang-javascript">window.history.back();
</code></pre>
<p>比如，返回前一个浏览的页面，<strong>代码如下：</strong></p>
<pre><code class="lang-javascript">window.history.back();
</code></pre>
<p><strong>注意：等同于点击浏览器的倒退按钮。</strong></p>
<p>back()相当于go(-1),<strong>代码如下:</strong></p>
<pre><code class="lang-javascript">window.history.go(-1);
</code></pre>
<h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><p>location用于获取或设置窗体的URL，并且可以用于解析URL。</p>
<p><strong>语法:</strong></p>
<pre><code>location.[属性|方法]
</code></pre><p><strong>location对象属性图示:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/53605c5a0001b26909900216.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/53605c5a0001b26909900216.jpg" alt="img"></a></p>
<p><strong>location 对象属性：</strong></p>
<p><strong><a href="http://img1.sycdn.imooc.com/5354b1d00001c4ec06220271.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5354b1d00001c4ec06220271.jpg" alt="img"></a></strong></p>
<p><strong>location 对象方法:</strong></p>
<p><strong><a href="http://img1.sycdn.imooc.com/5354b1eb00016a2405170126.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5354b1eb00016a2405170126.jpg" alt="img"></a></strong></p>
<h3 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h3><p>Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。</p>
<p><strong>对象属性:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/5354cff70001428b06880190.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5354cff70001428b06880190.jpg" alt="img"></a></p>
<p>查看浏览器的名称和版本，<strong>代码如下:</strong></p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
   var browser=navigator.appName;
   var b_version=navigator.appVersion;
   document.write(&quot;Browser name&quot;+browser);
   document.write(&quot;&lt;br&gt;&quot;);
   document.write(&quot;Browser version&quot;+b_version);
&lt;/script&gt;
</code></pre>
<p>返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)</p>
<p><strong>语法</strong></p>
<pre><code>navigator.userAgent
</code></pre><p>几种浏览的user_agent.，像360的兼容模式用的是IE、极速模式用的是chrom的内核。</p>
<p><a href="http://img1.sycdn.imooc.com/535a3a4a0001e03f06870189.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/535a3a4a0001e03f06870189.jpg" alt="img"></a></p>
<p>使用userAgent判断使用的是什么浏览器(假设使用的是IE8浏览器),<strong>代码如下:</strong></p>
<pre><code class="lang-javascript">function validB(){ 
  var u_agent = navigator.userAgent; 
  var B_name=&quot;Failed to identify the browser&quot;; 
  if(u_agent.indexOf(&quot;Firefox&quot;)&gt;-1){ 
      B_name=&quot;Firefox&quot;; 
  }else if(u_agent.indexOf(&quot;Chrome&quot;)&gt;-1){ 
      B_name=&quot;Chrome&quot;; 
  }else if(u_agent.indexOf(&quot;MSIE&quot;)&gt;-1&amp;&amp;u_agent.indexOf(&quot;Trident&quot;)&gt;-1){ 
      B_name=&quot;IE(8-10)&quot;;  
  }
    document.write(&quot;B_name:&quot;+B_name+&quot;&lt;br&gt;&quot;);
    document.write(&quot;u_agent:&quot;+u_agent+&quot;&lt;br&gt;&quot;); 
}
</code></pre>
<p><strong>运行结果:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/535dea1e00017b0b06880265.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/535dea1e00017b0b06880265.jpg" alt="img"></a></p>
<h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>screen对象用于获取用户的屏幕信息。</p>
<p><strong>语法：</strong></p>
<pre><code class="lang-javascript">window.screen.属性
</code></pre>
<p><strong>对象属性:</strong></p>
<p><strong><a href="http://img1.sycdn.imooc.com/5354d2810001a47706210213.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5354d2810001a47706210213.jpg" alt="img"></a></strong></p>
<h3 id="编程练习-2"><a href="#编程练习-2" class="headerlink" title="编程练习"></a>编程练习</h3><p>制作一个跳转提示页面：</p>
<p><strong>要求：</strong></p>
<p>\1. 如果打开该页面后，如果不做任何操作则5秒后自动跳转到一个新的地址，如慕课网主页。</p>
<p>\2. 如果点击“返回”按钮则返回前一个页面。</p>
<p><strong>效果:</strong></p>
<p><strong><a href="http://img1.sycdn.imooc.com/537d6fed0001572608080402.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/537d6fed0001572608080402.jpg" alt="img"></a></strong></p>
<p><strong>注意: 在窗口中运行该程序时，该窗口一定要有历史浏览记录，否则”返回”无效果。</strong></p>
<p><strong>任务</strong></p>
<p>第一步： 先编写好网页布局，如下:</p>
<p>  <a href="http://img1.sycdn.imooc.com/537d6eba0001779f03840115.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/537d6eba0001779f03840115.jpg" alt="img"></a></p>
<p>第二步： 获取显示秒数的元素，通过定时器来更改秒数。</p>
<p>第三步： 通过window的location和history对象来控制网页的跳转。</p>
<p>代码：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;浏览器对象&lt;/title&gt;  
 &lt;/head&gt;
 &lt;body&gt;
  &lt;!--先编写好网页布局--&gt;
  &lt;h1&gt;操作成功&lt;/h1&gt;
  &lt;input type=&quot;text&quot; id=&quot;mytime&quot;value=&quot;5&quot;&gt;&lt;/input&gt;
  &lt;span&gt;秒后回到主页&lt;/span&gt;
  &lt;script type=&quot;text/javascript&quot;&gt; 
   //获取显示秒数的元素，通过定时器来更改秒数。
   var num=5;
    function changeNum(){
        document.getElementById(&quot;mytime&quot;).value=num;
        num=num-1;
        if(num==0){
            window.location=&quot;http://www.imooc.com/&quot;;
        }
    }
    setInterval(&quot;changeNum()&quot;,1000);
    //changeNum();
   //通过window的location和history对象来控制网页的跳转。
 &lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="认识DOM"><a href="#认识DOM" class="headerlink" title="认识DOM"></a>认识DOM</h2><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p>
<p><strong>先来看看下面代码:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/5375ca640001c67307860420.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5375ca640001c67307860420.jpg" alt="img"></a></p>
<p><strong>将HTML代码分解为DOM节点层次图:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/5375ca7e0001dd8d04830279.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5375ca7e0001dd8d04830279.jpg" alt="img"></a></p>
<p><strong>HTML**</strong>文档可以说由节点构成的集合，DOM节点有:**</p>
<p><strong>1.</strong> <strong>元素节点：</strong>上图中<html>、<body>、<p>等都是元素节点，即标签。</p>
<p><strong>2.</strong> <strong>文本节点:</strong>向用户展示的内容，如<li>...</li>中的JavaScript、DOM、CSS等文本。</p>
<p><strong>3.</strong> <strong>属性节点:</strong>元素属性，如<a>标签的链接属性href=”<a href="http://www.imooc.com&quot;。" target="_blank" rel="noopener">http://www.imooc.com&quot;。</a></p>
<p><strong>节点属性:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/5375c953000117ee05240129.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5375c953000117ee05240129.jpg" alt="img"></a></p>
<p><strong>遍历节点树:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/53f17a6400017d2905230219.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/53f17a6400017d2905230219.jpg" alt="img"></a></p>
<p><strong>以上图ul为例，它的父级节点body,它的子节点3个li,它的兄弟结点h2、P。</strong></p>
<p><strong>DOM操作:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/538d29da000152db05360278.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/538d29da000152db05360278.jpg" alt="img"></a></p>
<p><strong>注意:</strong>前两个是document方法。</p>
<h3 id="区别getElementByID-getElementsByName-getElementsByTagName"><a href="#区别getElementByID-getElementsByName-getElementsByTagName" class="headerlink" title="区别getElementByID,getElementsByName,getElementsByTagName"></a>区别<code>getElementByID,getElementsByName,getElementsByTagName</code></h3><p><strong>以人来举例说明，人有能标识身份的身份证，有姓名，有类别(大人、小孩、老人)等。</strong></p>
<ol>
<li><p>ID 是一个人的身份证号码，是唯一的。所以通过<code>getElementById</code>获取的是指定的一个人。</p>
</li>
<li><p>Name 是他的名字，可以重复。所以通过<code>getElementsByName</code>获取名字相同的人集合。</p>
</li>
<li><p><code>TagName</code>可看似某类，<code>getElementsByTagName</code>获取相同类的人集合。如获取小孩这类人，<code>getElementsByTagName(&quot;小孩&quot;)</code>。</p>
</li>
</ol>
<p><strong>把上面的例子转换到HTML中，如下:</strong></p>
<pre><code class="lang-javascript">&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby1&quot;&gt;  音乐
</code></pre>
<p>input标签就像人的类别。</p>
<p>name属性就像人的姓名。</p>
<p>id属性就像人的身份证。</p>
<p><strong>方法总结如下:</strong></p>
<p><a href="http://img1.sycdn.imooc.com/5405263300018bcf05760129.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5405263300018bcf05760129.jpg" alt="img"></a></p>
<p><strong>注意：</strong>方法区分大小写</p>
<p>通过下面的例子(6个name=”hobby”的复选项，两个按钮)来区分三种方法的不同:</p>
<pre><code class="lang-javascript">  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby1&quot;&gt;  音乐
  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby2&quot;&gt;  登山
  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby3&quot;&gt;  游泳
  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby4&quot;&gt;  阅读
  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby5&quot;&gt;  打球
  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby6&quot;&gt;  跑步 
  &lt;input type=&quot;button&quot; value = &quot;全选&quot; id=&quot;button1&quot;&gt;
  &lt;input type=&quot;button&quot; value = &quot;全不选&quot; id=&quot;button1&quot;&gt;
</code></pre>
<ol>
<li><p><code>document.getElementsByTagName(&quot;input&quot;)</code>，结果为获取所有标签为input的元素，共8个。</p>
</li>
<li><p><code>document.getElementsByName(&quot;hobby&quot;)</code>，结果为获取属性name=”hobby”的元素，共6个。</p>
</li>
<li><p><code>document.getElementById(&quot;hobby6&quot;)</code>，结果为获取属性id=”hobby6”的元素，只有一个，”跑步”这个复选项。</p>
</li>
</ol>
<h3 id="编程练习-3"><a href="#编程练习-3" class="headerlink" title="编程练习"></a>编程练习</h3><p>1.在第27行处补充完整，实现当点击”全选”按钮时，将选中所有的复选项。</p>
<pre><code>提示:document.getElementsByTagName(&quot;input&quot;)获取的是所有input标签，包括复选项和按钮，所以要判断是否是复选项，如是选中。
</code></pre><p>2.在第33行处补充完整，实现当点击”全不选”按钮时，将取消所有选中的复选项。</p>
<p>3.在第40行处补充完整，在文本框中输入输入1-6数值，当点击”确定”按钮时，根据输入的数值，通过id选中相应的复选项。</p>
<p>代码：</p>
<pre><code class="lang-php+HTML">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;无标题文档&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;form&gt;
          请选择你爱好:&lt;br&gt;
          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby1&quot;&gt;  音乐
          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby2&quot;&gt;  登山
          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby3&quot;&gt;  游泳
          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby4&quot;&gt;  阅读
          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby5&quot;&gt;  打球
          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;hobby6&quot;&gt;  跑步 &lt;br&gt;
          &lt;input type=&quot;button&quot; value = &quot;全选&quot; onclick = &quot;checkall();&quot;&gt;
          &lt;input type=&quot;button&quot; value = &quot;全不选&quot; onclick = &quot;clearall();&quot;&gt;
          &lt;p&gt;请输入您要选择爱好的序号，序号为1-6:&lt;/p&gt;
          &lt;input id=&quot;wb&quot; name=&quot;wb&quot; type=&quot;text&quot; &gt;
          &lt;input name=&quot;ok&quot; type=&quot;button&quot; value=&quot;确定&quot; onclick = &quot;checkone();&quot;&gt;
        &lt;/form&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
        function checkall(){
            var hobby = document.getElementsByTagName(&quot;input&quot;);
        // 任务1 
           for(var i=0;i&lt;hobby.length;i++)
           {
               hobby[i].checked=true;
           }
        }
        function clearall(){
            var hobby = document.getElementsByName(&quot;hobby&quot;);
            for(var i=0;i&lt;hobby.length;i++)
            {
                hobby[i].checked=false;
            }
        // 任务2    

        }

        function checkone(){
            var j=document.getElementById(&quot;wb&quot;).value;
            if(parseInt(j)&gt;6||parseInt(j)&lt;0)
            {
                alert(&quot;请输入1-6之间的数字&quot;);
            }
        // 任务3
            var hobby=document.getElementsByTagName(&quot;input&quot;);
            hobby[parseInt(j)-1].checked=true;
        }

        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：</p>
<ol>
<li><code>nodeName</code> : 节点的名称</li>
<li><code>nodeValue</code> ：节点的值</li>
<li><code>nodeType</code> ：节点的类型</li>
</ol>
<p><strong>一、<code>nodeName</code> 属性:</strong> 节点的名称，是只读的。</p>
<ol>
<li>元素节点的 <code>nodeName</code> 与标签名相同</li>
<li>属性节点的 <code>nodeName</code> 是属性的名称</li>
<li>文本节点的 <code>nodeName</code> 永远是 <code>#text</code></li>
<li>文档节点的 <code>nodeName</code> 永远是 <code>#document</code></li>
</ol>
<p><strong>二、<code>nodeValue</code> 属性：</strong>节点的值</p>
<ol>
<li>元素节点的 <code>nodeValue</code> 是 undefined 或 null</li>
<li>文本节点的 <code>nodeValue</code> 是文本自身</li>
<li>属性节点的 <code>nodeValue</code> 是属性的值</li>
</ol>
<p><strong>三、<code>nodeType</code> 属性:</strong> 节点的类型，是只读的。以下常用的几种结点类型:</p>
<p><strong>元素类型   节点类型</strong><br>  元素      1<br>  属性      2<br>  文本      3<br>  注释      8<br>  文档      9</p>
<h3 id="插入节点appendChild"><a href="#插入节点appendChild" class="headerlink" title="插入节点appendChild()"></a>插入节点<code>appendChild()</code></h3><p>在指定节点的最后一个子节点列表之后添加一个新的子节点。</p>
<p><strong>语法:</strong></p>
<pre><code>appendChild(newnode)
</code></pre><p><strong>参数:</strong></p>
<p><code>newnode</code>：指定追加的节点。</p>
<p>我们来看看，div标签内创建一个新的 P 标签，代码如下:</p>
<p><a href="http://img1.sycdn.imooc.com/5398fd020001ad4905890193.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5398fd020001ad4905890193.jpg" alt="img"></a></p>
<p><strong>运行结果:</strong></p>
<pre><code class="lang-javascript">HTML
JavaScript
This is a new p
</code></pre>
<h3 id="插入节点insertBefore"><a href="#插入节点insertBefore" class="headerlink" title="插入节点insertBefore()"></a>插入节点<code>insertBefore()</code></h3><p><code>insertBefore()</code> 方法可在已有的子节点前插入一个新的子节点。</p>
<p><strong>语法:</strong></p>
<p><code>insertBefore(newnode,node);</code></p>
<p><strong>参数:</strong></p>
<p><code>newnode:</code> 要插入的新节点。</p>
<p>node: 指定此节点前插入节点。</p>
<p>我们在来看看下面代码，在指定节点前插入节点。</p>
<p><a href="http://img1.sycdn.imooc.com/5395318100010c6806960431.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/5395318100010c6806960431.jpg" alt="img"></a></p>
<p><strong>运行结果:</strong></p>
<pre><code class="lang-javascript">This is a new p
JavaScript
HTML
</code></pre>
<p><strong>注意:</strong> <code>otest.insertBefore(newnode,node);</code> 也可以改为: <code>otest.insertBefore(newnode,otest.childNodes[0]);</code> </p>
<h3 id="替换元素节点replaceChild"><a href="#替换元素节点replaceChild" class="headerlink" title="替换元素节点replaceChild()"></a>替换元素节点<code>replaceChild()</code></h3><p><code>replaceChild</code> 实现子节点(对象)的替换。返回被替换对象的引用。 </p>
<p><strong>语法：</strong></p>
<pre><code class="lang-javascript">node.replaceChild (newnode,oldnew )
</code></pre>
<p><strong>参数：</strong></p>
<p>newnode : 必需，用于替换 oldnew 的对象。<br> oldnew : 必需，被 newnode 替换的对象。</p>
<p>我们来看看下面的代码:</p>
<p><a href="http://img1.sycdn.imooc.com/539557d70001c3ee07190429.jpg" target="_blank" rel="noopener"><img src="http://img1.sycdn.imooc.com/539557d70001c3ee07190429.jpg" alt="img"></a> </p>
<p>效果: 将文档中的 Java 改为 JavaScript。</p>
<p><strong>注意:</strong> </p>
<ol>
<li><p>当 oldnode 被替换时，所有与之相关的属性内容都将被移除。 </p>
</li>
<li><p>newnode 必须先被建立。 </p>
</li>
</ol>
<h3 id="创建元素节点createElement"><a href="#创建元素节点createElement" class="headerlink" title="创建元素节点createElement"></a>创建元素节点createElement</h3><p>createElement()方法可创建元素节点。此方法可返回一个 Element 对象。</p>
<p><strong>语法：</strong></p>
<pre><code class="lang-javascript">document.createElement(tagName)
</code></pre>
<p><strong>参数:</strong></p>
<p>tagName：字符串值，这个字符串用来指明创建元素的类型。</p>
<p><strong>注意：</strong>要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。</p>
<p>我们来创建一个按钮，代码如下：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
   var body = document.body; 
   var input = document.createElement(&quot;input&quot;);  
   input.type = &quot;button&quot;;  
   input.value = &quot;创建一个按钮&quot;;  
   body.appendChild(input);  
 &lt;/script&gt;
</code></pre>
<p>效果：在HTML文档中，创建一个按钮。</p>
<p>我们也可以使用setAttribute来设置属性，代码如下：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;  
   var body= document.body;             
   var btn = document.createElement(&quot;input&quot;);  
   btn.setAttribute(&quot;type&quot;, &quot;text&quot;);  
   btn.setAttribute(&quot;name&quot;, &quot;q&quot;);  
   btn.setAttribute(&quot;value&quot;, &quot;使用setAttribute&quot;);  
   btn.setAttribute(&quot;onclick&quot;, &quot;javascript:alert(&#39;This is a text!&#39;);&quot;);       
   body.appendChild(btn);  
&lt;/script&gt;
</code></pre>
<p>效果：在HTML文档中，创建一个文本框，使用setAttribute设置属性值。 当点击这个文本框时，会弹出对话框“This is a text!”。</p>
<h3 id="网页卷去的距离与偏移量"><a href="#网页卷去的距离与偏移量" class="headerlink" title="网页卷去的距离与偏移量"></a>网页卷去的距离与偏移量</h3><p><strong>我们先来看看下面的图：</strong></p>
<p><a href="http://img.mukewang.com/5347b2b10001e1a307520686.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/5347b2b10001e1a307520686.jpg" alt="img"></a></p>
<p><strong>scrollLeft:</strong>设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。</p>
<p><strong>scrollTop:</strong>设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。</p>
<p><strong>offsetLeft:</strong>获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。</p>
<p><strong>offsetTop:</strong>获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。</p>
<p><strong>注意:</strong></p>
<p><strong>1. 区分大小写</strong></p>
<p><strong>2. offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。</strong></p>
<p>代码：</p>
<pre><code class="lang-html">&lt;!DOCTYPE HTML&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function req(){
          var div = document.getElementById(&quot;div1&quot;);
          document.getElementById(&quot;li1&quot;).innerHTML = (div.offsetTop)+&quot;px&quot;;//div1距离屏幕顶部的距离
          document.getElementById(&quot;li2&quot;).innerHTML = (div.offsetLeft)+&quot;px&quot;;//div1距离屏幕左部的距离
          document.getElementById(&quot;li3&quot;).innerHTML = (div.scrollTop)+&quot;px&quot;;//div1纵向滚动条滚动的距离
          document.getElementById(&quot;li4&quot;).innerHTML = (div.scrollLeft)+&quot;px&quot;;//div1横向滚动条滚动的距离
     }
&lt;/script&gt;
&lt;/head&gt;
&lt;body style=&quot;border:10px solid #ccc;padding:0px 0px;margin:5px 10px&quot;&gt;
    &lt;div style=&quot;width:60%;border-right:3px dashed blue;float:left;&quot;&gt;
        &lt;div style=&quot;float:left;&quot;&gt;
            &lt;div id=&quot;div1&quot; style=&quot;border:5px blue solid;height:300px;width:200px;overflow:auto&quot;&gt;
                &lt;div style=&quot;height:500px;width:400px&quot;&gt;请调整横竖滚动条后，点击按钮后查看offsetTop、offsetLeft、scrollTop、scrollLeft值。&lt;/div&gt;
            &lt;/div&gt;
            &lt;input type=&quot;button&quot; value=&quot;点击我!&quot; onclick=&quot;req()&quot; style=&quot;border: 1px solid purple;height: 55px;&quot;/&gt;
        &lt;/div&gt;

    &lt;/div&gt;
    &lt;div style=&quot;width:35%;height:65px;float:right;&quot;&gt;
        &lt;ul style=&quot;list-style-type: none; line-height:38px;ss&quot;&gt;结果：
            &lt;li&gt;offsetTop : &lt;span id=&quot;li1&quot;&gt;&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;offsetLeft : &lt;span id=&quot;li2&quot;&gt;&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt; scrollTop : &lt;span id=&quot;li3&quot;&gt;&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;scrollLeft : &lt;span id=&quot;li4&quot;&gt;&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;总结：offsetLeft与offsetTop的值是相对不变的。&lt;span id=&quot;lix&quot;&gt;&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;

    &lt;/div&gt;
    &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;    
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="编程练习-4"><a href="#编程练习-4" class="headerlink" title="编程练习"></a>编程练习</h3><p>制作一个表格，显示班级的学生信息。</p>
<p><strong>要求：</strong></p>
<ol>
<li><p>鼠标移到不同行上时背景色改为色值为 #f2f2f2，移开鼠标时则恢复为原背景色 #fff</p>
</li>
<li><p>点击添加按钮，能动态在最后添加一行</p>
</li>
<li><p>点击删除按钮，则删除当前行</p>
</li>
</ol>
<p><strong>任务</strong></p>
<p>第一步： 首先，我们创建删除函数，并在删除按钮上添加点击事件；</p>
<pre><code class="lang-javascript">提示: 使用removeChild()。
</code></pre>
<p>第二步： 编写一个函数，供添加按钮调用，动态在表格的最后一行添加子节点；</p>
<pre><code class="lang-javascript">提示: 使用createElement()、innerHTML、appendChild()。
</code></pre>
<p>第三步： 更改鼠标移动改变背景则可以通过给每行绑定鼠标移上事件和鼠标移除事件来改变所在行背景色。</p>
<pre><code class="lang-javascript">提示:
1. 获取表格的行，getElementsByTagName 。
2. 使用for进行循环，为每行添加事件及背景颜色设置。
</code></pre>
<p>代码：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt; new document &lt;/title&gt; 
  &lt;script type=&quot;text/javascript&quot;&gt; 

      window.onload = function(){
     // 鼠标移动改变背景,可以通过给每行绑定鼠标移上事件和鼠标移除事件来改变所在行背景色。
        var tr=document.getElementById(&quot;tr&quot;);
        for(var i=0;i&lt;tr.length;i++)
        {
            btrchange(tr[i]);
        }
     }
    function btrchange(obj)
    {
        obj.onmouseover=function()
        {
            obj.style.backgroundColor=&quot;#f2f2f2&quot;;
        }
        obj.onmouseout=function()
        {
            obj.style.backgroundColor=&quot;#fff&quot;;
        }
    }
      // 编写一个函数，供添加按钮调用，动态在表格的最后一行添加子节点；
     function add()
     {
        var num=prompt(&quot;请输入学号&quot;);
        var name=prompt(&quot;请输入姓名&quot;);
        var newtr=document.createElement(&quot;tr&quot;);
        newtr.innerHTML=&quot;&lt;td&gt;&quot;+num+&quot;&lt;/td&gt;&quot;+&quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+&#39;&lt;td&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;del(this)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#39;;
        var table=document.getElementById(&quot;table&quot;).lastChild;
        table.appendChild(newtr);
     }

     // 创建删除函数
     function del(obj)
     {
        var table=document.getElementById(&quot;table&quot;).lastChild;
        var tr=obj.parentNode.parentNode;
        table.removeChild(tr);
     }


  &lt;/script&gt; 
 &lt;/head&gt; 
 &lt;body&gt; 
       &lt;table border=&quot;1&quot; width=&quot;50%&quot; id=&quot;table&quot;&gt;
       &lt;tr&gt;
        &lt;th&gt;学号&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
       &lt;/tr&gt;  

       &lt;tr&gt;
        &lt;td&gt;xh001&lt;/td&gt;
        &lt;td&gt;王小明&lt;/td&gt;
        &lt;td&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;del(this)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;   &lt;!--在删除按钮上添加点击事件  --&gt;
       &lt;/tr&gt;

       &lt;tr&gt;
        &lt;td&gt;xh002&lt;/td&gt;
        &lt;td&gt;刘小芳&lt;/td&gt;
        &lt;td&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;del(this)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;   &lt;!--在删除按钮上添加点击事件  --&gt;
       &lt;/tr&gt;

       &lt;/table&gt;
       &lt;input type=&quot;button&quot; value=&quot;添加一行&quot;  onclick=&quot;add()&quot;/&gt;   &lt;!--在添加按钮上添加点击事件  --&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="编程挑战"><a href="#编程挑战" class="headerlink" title="编程挑战"></a>编程挑战</h2><p>现在利用之前我们学过的JavaScript知识，实现选项卡切换的效果。</p>
<p><strong>效果图:</strong></p>
<p><img src="http://img1.sycdn.imooc.com/53bd0e9e000163d203390200.jpg" alt="img"></p>
<p><strong>文字素材:</strong></p>
<p>房产：</p>
<p>  275万购昌平邻铁三居 总价20万买一居<br>   200万内购五环三居 140万安家东三环<br>   北京首现零首付楼盘 53万购东5环50平<br>   京楼盘直降5000 中信府 公园楼王现房</p>
<p>家居:</p>
<p>   40平出租屋大改造 美少女的混搭小窝<br>    经典清新简欧爱家 90平老房焕发新生<br>    新中式的酷色温情 66平撞色活泼家居<br>    瓷砖就像选好老婆 卫生间烟道的设计</p>
<p>二手房：</p>
<p>   通州豪华3居260万 二环稀缺2居250w甩<br>    西3环通透2居290万 130万2居限量抢购<br>    黄城根小学学区仅260万 121平70万抛!<br>    独家别墅280万 苏州桥2居优惠价248万</p>
<p><strong>任务</strong></p>
<p>大家先思考和分析实现思路，然后在动手实现</p>
<p>一、HTML页面布局</p>
<pre><code>提示:
选项卡标题使用ul..li
选项卡内容使用div
</code></pre><p>二、CSS样式制作</p>
<pre><code>提示:
整个选项卡的样式设置
选项卡标题的样式设置
选项卡内容的样式设置
一开始只显示一个选项卡内容，其它选项卡内容隐藏。
</code></pre><p>三、JS实现选项卡切换</p>
<pre><code>提示:
获取选项卡标题和选项卡内容
选项卡内容多个，需要循环遍历来操作，得知哪个选项卡和哪个选项内容匹配
通过改变DOM的css类名称,当前点击的选项卡显示，其它隐藏。
</code></pre><p>代码：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;title&gt;实践题 - 选项卡&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
     /* 
     标签和文本结合区域效果制作：
     1.用ul做分类标签
     2.把ul的display定义为block使ul区域和下面div区域结合在一起
     3.给ul定义一个下边框或者给div内容区域定义一个上边框
     4.所有li标签默认样式不设下边框，作为激活显示的li标签加宽其#fff（白色）
     区域的下边框，覆盖。
     */  
*{
    margin:0px; padding:0px; font:12px normal; font-family:微软雅黑;
    }       
 #tabs{
     width:290px; height:150px; padding:5px; margin:20px;
 }
 #tabs ul{
     list-style:none; display:block; height:30px; line-height:30px;
 }
 #tabs ul li{
     float:left; width:60px; height:28px; line-height:28px; text-align:center;
     display:inline-block;margin:0px 3px; border:1px solid #aaa;border-bottom:none;
     cursor:pointer; background:#fff; list-style:none;
 }
 #tabs ul li.on{
     border-top:2px solid saddlebrown; border-bottom:2px solid #fff;
 }
 #tabs div{
     height:120px; line-height:25px; border:1px solid #336699;border-top:2px saddlebrown solid;padding:5px;
 }
 .hide{display:none;}
    &lt;/style&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;

    window.onload=function(){
        var tabs=document.getElementById(&quot;tabs&quot;);
        var sli=document.getElementsByTagName(&quot;li&quot;);
        var sdiv=tabs.getElementsByTagName(&quot;div&quot;);
        for(var i=0;i&lt;sli.length;i++)
        {
            sli[i].index=i;
            sli[i].onmouseover=function(){
                for(var j=0;j&lt;sli.length;j++)
                {
                    sli[j].className=&quot;&quot;;
                    sdiv[j].className=&quot;hide&quot;;
                }
                this.className=&quot;on&quot;;
                sdiv[this.index].className=&quot;&quot;;
            }
        }
    }

    &lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;!-- HTML页面布局 --&gt;
&lt;div id=&quot;tabs&quot;&gt;
    &lt;ul&gt;
        &lt;li class=&quot;on&quot;&gt;房产&lt;/li&gt;
        &lt;li&gt;家居&lt;/li&gt;
        &lt;li&gt;二手房&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div&gt;
    275万购昌平邻铁三居 总价20万买一居&lt;br&gt;
    200万内购五环三居 140万安家东三环&lt;br&gt;
    北京首现零首付楼盘 53万购东5环50平&lt;br&gt;
    京楼盘直降5000 中信府 公园楼王现房&lt;br&gt;
    &lt;/div&gt;
    &lt;div class=&quot;hide&quot;&gt;
     40平出租屋大改造 美少女的混搭小窝&lt;br&gt;
     经典清新简欧爱家 90平老房焕发新生&lt;br&gt;
     新中式的酷色温情 66平撞色活泼家居&lt;br&gt;
     瓷砖就像选好老婆 卫生间烟道的设计&lt;br&gt;
    &lt;/div&gt;
    &lt;div class=&quot;hide&quot;&gt;
     通州豪华3居260万 二环稀缺2居250w甩&lt;br&gt;
     西3环通透2居290万 130万2居限量抢购&lt;br&gt;
     黄城根小学学区仅260万 121平70万抛!&lt;br&gt;
     独家别墅280万 苏州桥2居优惠价248万&lt;br&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript入门篇</title>
    <url>/2020/01/28/JS%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<p>关于JS基础知识<br><a id="more"></a></p>
<h2 id="JS入门篇"><a href="#JS入门篇" class="headerlink" title="JS入门篇"></a>JS入门篇</h2><h3 id="JS-确认（confirm-消息对话框）"><a href="#JS-确认（confirm-消息对话框）" class="headerlink" title="JS-确认（confirm 消息对话框）"></a>JS-确认（confirm 消息对话框）</h3><p>confirm 消息对话框通常用于允许用户做选择的动作，如: “你对吗？”等。弹出对话框（包括确认按钮和一个取消按钮）。</p>
<p>语法：</p>
<pre><code class="lang-javascript">confirm(str);
</code></pre>
<p>参数说明：</p>
<pre><code class="lang-javascript">str: 再消息对话框中要显示的文本
返回值：Boolean值
</code></pre>
<p>返回值：</p>
<pre><code class="lang-javascript">当用户点击&quot;确认&quot;按钮时，返回true
当用户点击&quot;取消&quot;按钮时，返回false
</code></pre>
<p><strong>注：通过返回值可以判断用户点击了什么按钮</strong></p>
<p>看下面的代码：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    var mymessage=confirm(&quot;你喜欢JavaScript吗?&quot;);
    if(mymessage==true)
    {   document.write(&quot;很好,加油!&quot;);   }
    else
    {  document.write(&quot;JS功能强大，要学习噢!&quot;);   }
&lt;/script&gt;
</code></pre>
<p>结果：</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1KugbQ.jpg" alt="1KugbQ.jpg"></p>
<h3 id="JS-提问（prompt-消息对话框）"><a href="#JS-提问（prompt-消息对话框）" class="headerlink" title="JS-提问（prompt 消息对话框）"></a>JS-提问（prompt 消息对话框）</h3><p>prompt 弹出消息对话框，通常用于询问一些需要与用户交互的消息，弹出消息对话框（包含一个确认按钮，取消按钮与一个文本输入框）。</p>
<p>语法：</p>
<pre><code class="lang-javascript">prompt(str1,str2);
</code></pre>
<p>参数说明：</p>
<pre><code>str1：要显示在消息对话框中的文本，不可修改
str2：文本框中的内容，可以修改
</code></pre><p>返回值：</p>
<pre><code>1.点击确认按钮，文本框中的内容将作为函数返回值
2.点击取消按钮，将返回null
</code></pre><p>看看下面代码：</p>
<pre><code class="lang-javascript">var myname=prompt(&quot;请输入你的姓名：&quot;)；
if(myname!=null)
{alert(&quot;你好&quot;+myname);}
else
{alert(&quot;你好 my friend.&quot;);}
</code></pre>
<p>结果：</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1KMEmF.jpg" alt="1KMEmF.jpg"></p>
<p><strong>注:在用户点击对话框的按钮前，不能进行任何其它操作。</strong></p>
<h3 id="JS-打开新窗口（window-open）"><a href="#JS-打开新窗口（window-open）" class="headerlink" title="JS-打开新窗口（window.open）"></a>JS-打开新窗口（window.open）</h3><p>open()方法可以查找一个已经存在或者新建的浏览器窗口。</p>
<p>语法：</p>
<pre><code class="lang-javascript">window.open([URL], [窗口名称], [参数字符串])
</code></pre>
<p>参数说明:</p>
<pre><code class="lang-javascript">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。
窗口名称：可选参数，被打开窗口的名称。
    1.该名称由字母、数字和下划线字符组成。
    2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。
       _blank：在新窗口显示目标网页
       _self：在当前窗口显示目标网页
       _top：框架网页中在上部窗口中显示目标网页
    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
   4.name 不能包含有空格。
参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。
</code></pre>
<p>参数表：</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1KQgbD.jpg" alt="1KQgbD.jpg"></p>
<p>例如:打开<a href="http://www.imooc.com网站，大小为300px" target="_blank" rel="noopener">http://www.imooc.com网站，大小为300px</a> * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：</p>
<pre><code class="lang-javascript">&lt;script type=&quot;text/javascript&quot;&gt; window.open(&#39;http://www.imooc.com&#39;,&#39;_blank&#39;,&#39;width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes&#39;)
&lt;/script&gt;
</code></pre>
<p><strong>注意：</strong>运行结果考虑浏览器兼容问题。</p>
<h3 id="JS-DOM操作"><a href="#JS-DOM操作" class="headerlink" title="JS DOM操作"></a>JS DOM操作</h3><h4 id="改变-HTML-的样式"><a href="#改变-HTML-的样式" class="headerlink" title="改变 HTML 的样式"></a>改变 HTML 的样式</h4><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式。如何改变 HTML 元素的样式呢？</p>
<p>语法：</p>
<pre><code class="lang-javascript">Object.style.property=new style;
</code></pre>
<p><strong>注意:</strong>Object是获取的元素对象，如通过<code>document.getElementById(&quot;id&quot;)</code>获取的元素。</p>
<p><strong>基本属性表（property）:</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/28/1Ktw1H.jpg" alt="1Ktw1H.jpg"></p>
<p><strong>注意:</strong>该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。</p>
<p>改变 <p> 元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝：</p>
<pre><code class="lang-javascript">&lt;p id=&quot;pcon&quot;&gt;Hello World!&lt;/p&gt;
&lt;script&gt;
   var mychar = document.getElementById(&quot;pcon&quot;);
   mychar.style.color=&quot;red&quot;;
   mychar.style.fontSize=&quot;20&quot;;
   mychar.style.backgroundColor =&quot;blue&quot;;
&lt;/script&gt;
</code></pre>
<p>结果:</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1KtrnI.jpg" alt="1KtrnI.jpg"></p>
<h3 id="显示和隐藏（display属性）"><a href="#显示和隐藏（display属性）" class="headerlink" title="显示和隐藏（display属性）"></a>显示和隐藏（display属性）</h3><p>网页中经常会看到显示和隐藏的效果，可通过display属性来设置。</p>
<p><strong>语法：</strong></p>
<pre><code>Object.style.display = value
</code></pre><p><strong>注意:</strong>Object是获取的元素对象，如通过<code>document.getElementById(&quot;id&quot;)</code>获取的元素。</p>
<p>value取值:</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1Kajgg.jpg" alt="1Kajgg.jpg"></p>
<h3 id="控制类名（className-属性）"><a href="#控制类名（className-属性）" class="headerlink" title="控制类名（className 属性）"></a>控制类名（className 属性）</h3><p>className 属性设置或返回元素的class 属性。</p>
<p><strong>语法：</strong></p>
<pre><code>object.className = classname
</code></pre><p><strong>作用:</strong></p>
<p>1.获取元素的class 属性</p>
<p>2.为网页内的某个元素指定一个css样式来更改该元素的外观</p>
<p>看看下面代码，获得  元素的 class 属性和改变className：</p>
<p><img src="https://s2.ax1x.com/2020/01/28/1KwCsH.jpg" alt="1KwCsH.jpg"></p>
<h3 id="总结-编程挑战"><a href="#总结-编程挑战" class="headerlink" title="总结 编程挑战"></a>总结 编程挑战</h3><p>小伙伴们，请编写”改变颜色”、”改变宽高”、”隐藏内容”、”显示内容”、”取消设置”的函数，点击相应按钮执行相应操作，点击”取消设置”按钮后，提示是否取消设置，如是执行操作，否则不做操作。</p>
<p>任务</p>
<p>一、定义”改变颜色”的函数</p>
<pre><code>提示:
obj.style.color
obj.style.backgroundColor
</code></pre><p>二、定义”改变宽高”的函数</p>
<pre><code>提示:
obj.style.width
obj.style.height
</code></pre><p>三、定义”隐藏内容”的函数</p>
<pre><code>提示:
obj.style.display=&quot;none&quot;;
</code></pre><p>四、定义”显示内容”的函数</p>
<pre><code>提示:
obj.style.display=&quot;block&quot;;
</code></pre><p>五、定义”取消设置”的函数</p>
<pre><code>提示: 
使用confirm()确定框，来确认是否取消设置。
如是将以上所有的设置恢复原始值,否则不做操作。
</code></pre><p>六、当点击相应按钮，执行相应操作，为按钮添加相应事件</p>
<pre><code class="lang-html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;javascript&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;
body{font-size:12px;}
#txt{
    height:400px;
    width:600px;
    border:#333 solid 1px;
    padding:5px;}
p{
    line-height:18px;
    text-indent:2em;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h2 id=&quot;con&quot;&gt;JavaScript课程&lt;/H2&gt;
  &lt;div id=&quot;txt&quot;&gt; 
     &lt;h5&gt;JavaScript为网页添加动态效果并实现与用户交互的功能。&lt;/h5&gt;
        &lt;p&gt;1. JavaScript入门篇，让不懂JS的你，快速了解JS。&lt;/p&gt;
        &lt;p&gt;2. JavaScript进阶篇，让你掌握JS的基础语法、函数、数组、事件、内置对象、BOM浏览器、DOM操作。&lt;/p&gt;
        &lt;p&gt;3. 学完以上两门基础课后，在深入学习JavaScript的变量作用域、事件、对象、运动、cookie、正则表达式、ajax等课程。&lt;/p&gt;
  &lt;/div&gt;
  &lt;form&gt;
  &lt;!--当点击相应按钮，执行相应操作，为按钮添加相应事件--&gt;
    &lt;input type=&quot;button&quot; value=&quot;改变颜色&quot; onclick=&quot;opt1()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;改变宽高&quot; onclick=&quot;opt2()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;隐藏内容&quot; onclick=&quot;opt3()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;显示内容&quot; onclick=&quot;opt4()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;取消设置&quot; onclick=&quot;opt5()&quot;&gt;
  &lt;/form&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
//定义&quot;改变颜色&quot;的函数
function opt1(){
  var myopt=document.getElementById(&quot;txt&quot;);
  myopt.style.color=&quot;red&quot;;
}

//定义&quot;改变宽高&quot;的函数
function opt2(){
  var myopt=document.getElementById(&quot;txt&quot;);
  myopt.style.width=&quot;500px&quot;;
  myopt.style.height=&quot;500px&quot;;
}

//定义&quot;隐藏内容&quot;的函数
function opt3(){
  var myopt=document.getElementById(&quot;txt&quot;);
  myopt.style.display=&quot;none&quot;;
}

//定义&quot;显示内容&quot;的函数
function opt4(){
  var myopt=document.getElementById(&quot;txt&quot;);
  myopt.style.display=&quot;block&quot;;
}

//定义&quot;取消设置&quot;的函数
function opt5(){
  var message=confirm(&quot;你确定要重置所有设置么？&quot;);
  if(message==true)
  {
    txt.removeAttribute(&#39;style&#39;);
  }
}

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>JS对象</title>
    <url>/2020/01/21/JS%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>关于JS对象的一些属性<br><a id="more"></a></p>
<h2 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h2><h3 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h3><pre><code class="lang-javascript">var man={
    name:&#39;Bosn&#39;,
    weibo:&#39;@Bosn&#39;,
    get age(){
        return new Date().getFullYear()-1995;
    },
    set age(val){
    console.log(&#39;等式右边是&#39;+val);
    }
}
console.log(man.age);//24，读get的属性
man.age=100;//等式右边是100，等式右边的值会传给set属性的形参val
console.log(man.age);//still 24,因为读的是get的age属性,并没有被改变
</code></pre>
<p>注意：get的属性不能被赋值！</p>
<h3 id="get-set与原型链"><a href="#get-set与原型链" class="headerlink" title="get/set与原型链"></a>get/set与原型链</h3><p><code>ps</code>:读取属性是自下而上寻找原型链</p>
<p>如果对象的原型上有一个属性，且这个属性是get法定义，则不能用<code>obj.property</code>的方式给当前对象添加同样名字的新属性。比如：</p>
<pre><code class="lang-javascript">function foo(){
    Object.defineProperty(foo.prototype,&#39;z&#39;,{get:function(){rerurn1;}});
｝
var obj =new foo();
obj.z;//1
obj.z=10;//没有以给当前对象obj添加新属性的方式形成属性
obj.z;//still 1
</code></pre>
<p>可以用<code>obj.defineProperty(obj,&#39;z&#39;,{value:10,configurable:true});</code>法实现添加属性</p>
<p>看到这里是不是有人会想 如何在<code>Javascript</code>中通过实例对象修改对象的属性值呢</p>
<p>让我们来看看<a href="https://www.cnblogs.com/fogwind/p/5750764.html" target="_blank" rel="noopener">大佬</a>怎么写的</p>
<h4 id="JS中通过实例对象修改对象的属性值问题"><a href="#JS中通过实例对象修改对象的属性值问题" class="headerlink" title="JS中通过实例对象修改对象的属性值问题"></a>JS中通过实例对象修改对象的属性值问题</h4><p><code>Javascript</code>中的数据值有两大类：基本类型的数据值和引用类型的数据值。</p>
<p>基本类型的数据值有5种：null、undefined、number、boolean和string。</p>
<p>引用类型的数据值往大的说就1种，即<code>Object</code>类型。往细的说有：<code>Object</code>类型、<code>Array</code>类型、<code>Date</code>类型、<code>Regexp</code>类型、<code>Function</code>类型等。</p>
<p><strong>当原型对象的属性值为基本类型的数据值时，通过实例对象修改属性值从而引起原型对象的属性值发生变化的情况不会发生。当原型对象的属性值为引用类型的数据值时，通过实例对象修改属性值就可能引起原型对象的属性值发生变化。下面举例说明。</strong></p>
<p>例1：</p>
<pre><code class="lang-javascript">function Animal() {}
Animal.prototype = {
 constructor: Animal,// constructor 保存了指向 function 的一个引用
 number: &quot;very much&quot;,
 fish: [&quot;shark&quot;,&quot;sardine&quot;],
 bird:{
     ability: &quot;fly&quot;,
     feature: &quot;feather&quot;
 }
};
var animal1 = new Animal();
var animal2 = new Animal();
//没有改变原型的number属性,而是自己获得了number属性
animal1.number = 1000;
console.log(animal2.number);//very much
</code></pre>
<p>上例中通过构造函数Animal创建了两个实例对象，两个实例对象继承了同一个原型对象的属性。通过实例对象animal1重新设置了number属性，结果是实例对象animal1拥有了自己的number属性，没有改变原型对象的number属性值，实例对象animal2调用的number属性还是原型对象原来的number属性。</p>
<p>例2：</p>
<pre><code class="lang-javascript">function Animal() {}
Animal.prototype = {
 constructor: Animal,
 number: &quot;very much&quot;,
 fish: [&quot;shark&quot;,&quot;sardine&quot;],
 bird:{
     ability: &quot;fly&quot;,
     feature: &quot;feather&quot;
 }
};
var animal1 = new Animal();
var animal2 = new Animal();
var animal3 = new Animal();
//没有改写原型中的fish属性,此时animal1实例对象中有了自己的fish属性，向其自己的fish属性中推入和弹出项不会改变原型的fish属性。
animal1.fish = [&quot;cold fish&quot;];
for (var i=0;i&lt;animal2.fish.length;i++) {
  console.log(animal2.fish[i]);//shark,sardine,没有cold fish
 }
//通过实例对象animal3向fish属性中推入项，改变了原型对象的fish属性，因为实例对象中没有自己的fish属性
animal3.fish.push(&quot;voladao&quot;);
animal3.fish[0] = &quot;fly fish&quot;;
for (var i=0;i&lt;animal2.fish.length;i++) {
  console.log(animal2.fish[i]);//fly fish,sardine,voladao
 }
</code></pre>
<p>例2中实例对象animal1创建了自己的fish属性，没有改变原型对象的fish属性，所以实例对象animal2输出的还是原型对象的fish属性。</p>
<p>实例对象animal3没有自己的fish属性，但通过实例对象animal3向fish属性中推入了一项，并且改变了其中的第一项的值，这些改变都发生在了原型对象的fish属性上，所以实例对象animal2调用fish属性时，其属性值发生了变化。</p>
<p>例3：</p>
<pre><code class="lang-javascript">function Animal() {}
Animal.prototype = {
 constructor: Animal,
 number: &quot;very much&quot;,
 fish: [&quot;shark&quot;,&quot;sardine&quot;],
 bird:{
     ability: &quot;fly&quot;,
     feature: &quot;feather&quot;
 }
}
var animal1 = new Animal();
var animal2 = new Animal();
var animal3 = new Animal();
var animal4 = new Animal();
var animal5 = new Animal();
//改写了原型中的bird属性
animal1.bird.ability = &quot;run&quot;;
console.log(animal2.bird.ability);//run
//创建animal3的bird属性，没有改变原型对象的bird属性
 animal3.bird = {
   eat: &quot;fish&quot;
 };
 console.log(animal4.bird.eat);//undifined
 console.log(animal3.bird.eat);//fish
 animal5.bird.home = &quot;tree&quot;;
 console.log(animal4.bird.home);//tree
</code></pre>
<p>例3中通过实例对象animal1修改了bird属性的ability属性的值，实例对象animal1没有自己的bird属性，这个修改反映在了原型对象的bird属性上，实例对象animal2输出的bird.ability的值是改变后的值。</p>
<p>实例对象animal3创建了自己的bird属性，这没有改变原型对象的bird属性，所以实例对象4的bird.eat的值为undifined。</p>
<p>通过实例对象animal5添加了bird属性的home属性，实例对象animal5没有自己的bird属性，这个home属性添加到了原型对象的bird属性上，所以animal4的bird.home的值为tree。</p>
<h4 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h4><p>Configurable,Enumerable,Writable,Value</p>
<pre><code class="lang-javascript">var person = {}
Object.defineProperty(person,&#39;name&#39;,{
    configurable:false,//能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true
    enumerable:false,//对象属性是否可通过for-in循环，flase为不可循环，默认值为true
    writable:false,//对象属性是否可修改,flase为不可修改，默认值为true
    value:&#39;xiaoming&#39; //对象属性的默认值，默认值为undefined
});

//value
console.log(person);//xiaoming，默认value

//writable
person.name=&quot;qiang&quot;;
console.log(person);//xiaoming，不可修改value

//enumerable
for(var i in person){
    console.log(person[i]) //无结果，不可循环
}

//configurable
delete person.name
console.log(person.name)//xiaoming，不可删除

Object.defineProperty(person,&#39;name&#39;,{
    configurable:true //不可修改，将抛出错误
});
</code></pre>
<p><img src="https://s2.ax1x.com/2020/01/21/1kJCRS.jpg" alt="1kJCRS.jpg"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型判断</title>
    <url>/2020/01/20/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>关于数据类型判断的一道编程题<br><a id="more"></a><br><strong>本习题将验证你是否已经熟练掌握了数据类型知识。记得看完视频讲解，也要结合看书更全面的学习知识哦！</strong></p>
<pre><code>温馨提示:完成任务后，请验证结果窗口显示是否是&quot;判定结果:通过&quot;,如是恭喜您，你已经掌握此技能，否则，建议重复学习此内容。
</code></pre><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>请在index.html文件中，编写arraysSimilar函数，实现判断传入的两个数组是否相似。具体需求：</p>
<ol>
<li><p>数组中的成员类型相同，顺序可以不同。例如[1, true] 与 [false, 2]是相似的。</p>
</li>
<li><p>数组的长度一致。</p>
</li>
<li><p>类型的判断范围，需要区分:String, Boolean, Number, undefined, null, 函数，日期, window.</p>
</li>
</ol>
<p>当以上全部满足，则返回”判定结果:通过”，否则返回”判定结果:不通过”。// 网站判断功能失效了</p>
<p><a href="https://www.imooc.com/code/5760" target="_blank" rel="noopener">题目链接</a></p>
<pre><code class="lang-javascript">function arraysSimilar(arr1, arr2){
            if(!(arr1 instanceof Array)||!(arr2 instanceof Array))
            {
                return false;
            }
            if(arr1.length!=arr2.length)
            return false;
            var n = arr1.length,
                countMap1 = {},
                countMap2 = {},
                t1,t2,
                TYPES=[&#39;string&#39;,&#39;boolean&#39;,&#39;number&#39;,&#39;undefined&#39;,&#39;null&#39;,&#39;function&#39;,&#39;data&#39;,&#39;window&#39;];
            for(var i=0;i&lt;n;i++)
            {
                t1=typeof(arr1[i]);
                t2=typeof(arr2[i]);
                if(countMap1[t1])
                {
                    countMap1[t1]++;
                }
                else
                countMap1[t1]=1;

                if(countMap2[t2])
                {
                    countMap2[t2]++;
                }
                else
                countMap2[t2]=1;
            }
            function typeof(value)
            {
                var r;
                if (value==null)
                r=&#39;null&#39;;
                else if (value instanceof Array)
                r=&#39;array&#39;;
                else if(value === window)
                r=&#39;window&#39;;
                else if(value instanceof Date)
                r=&#39;data&#39;;
                else r= typeof value;
                return r;
            }
            for(var i=0,n=TYPES.length;i&lt;n;i++)
            {
                if(countMap1[TYPES[i]]!=countMap2[TYPES[i]])
                retunr false;
            }
            return true;
        }
</code></pre>
<p>数据：</p>
<pre><code class="lang-javascript">var result=function(){
    //以下为多组测试数据
            var cases=[{
                    arr1:[1,true,null],
                    arr2:[null,false,100],
                    expect:true
                },{
                    arr1:[function(){},100],
                    arr2:[100,{}],
                    expect:false
                },{
                    arr1:[null,999],
                    arr2:[{},444],
                    expect:false
                },{
                    arr1:[window,1,true,new Date(),&quot;hahaha&quot;,(function(){}),undefined],
                    arr2:[undefined,(function(){}),&quot;okokok&quot;,new Date(),false,2,window],
                    expect:true
                },{
                    arr1:[new Date()],
                    arr2:[{}],
                    expect:false
                },{
                    arr1:[window],
                    arr2:[{}],
                    expect:false
                },{
                    arr1:[undefined,1],
                    arr2:[null,2],
                    expect:false
                },{
                    arr1:[new Object,new Object,new Object],
                    arr2:[{},{},null],
                    expect:false
                },{
                    arr1:null,
                    arr2:null,
                    expect:false
                },{
                    arr1:[],
                    arr2:undefined,
                    expect:false
                },{
                    arr1:&quot;abc&quot;,
                    arr2:&quot;cba&quot;,
                    expect:false
                }];

    //使用for循环, 通过arraysSimilar函数验证以上数据是否相似，如相似显示“通过”,否则&quot;不通过&quot;,所以大家要完成arraysSimilar函数,具体要求，详见任务要求。    
            for(var i=0;i&lt;cases.length;i++){
                if(arraysSimilar(cases[i].arr1,cases[i].arr2)!==cases[i].expect) {
                    document.write(&quot;不通过！case&quot;+(i+1)+&quot;不正确！arr1=&quot;+JSON.stringify(cases[i].arr1)+&quot;, arr2=&quot;+JSON.stringify(cases[i].arr2)+&quot; 的判断结果不是&quot;+cases[i].expect);
                    return false;
                }                
            }
            return true;

        }();
    document.write(&quot;判定结果:&quot;+(result?&quot;通过&quot;:&quot;不通过&quot;));
</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数据类型</title>
    <url>/2020/01/20/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>关于JS的6中数据类型<br><a id="more"></a></p>
<h1 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h1><h3 id="1-六种数据类型"><a href="#1-六种数据类型" class="headerlink" title="1.六种数据类型"></a>1.六种数据类型</h3><p><img src="https://s2.ax1x.com/2020/01/21/1FBhgx.png" alt="1FBhgx.png"></p>
<h3 id="2-隐式转换"><a href="#2-隐式转换" class="headerlink" title="2.隐式转换"></a>2.隐式转换</h3><h4 id="隐式转换逻辑：字符串-数字，默认字符串相加；字符串-数字，会先把字符串隐式转换成数字再计算。巧用隐式转换可以将字符串和数字类型相互转换；如图-0或-‘’"><a href="#隐式转换逻辑：字符串-数字，默认字符串相加；字符串-数字，会先把字符串隐式转换成数字再计算。巧用隐式转换可以将字符串和数字类型相互转换；如图-0或-‘’" class="headerlink" title="隐式转换逻辑：字符串+数字，默认字符串相加；字符串-数字，会先把字符串隐式转换成数字再计算。巧用隐式转换可以将字符串和数字类型相互转换；如图-0或+‘’"></a>隐式转换逻辑：字符串+数字，默认字符串相加；字符串-数字，会先把字符串隐式转换成数字再计算。巧用隐式转换可以将字符串和数字类型相互转换；如图-0或+‘’</h4><p><img src="https://s2.ax1x.com/2020/01/21/1FBj2t.jpg" alt="1FBj2t.jpg"></p>
<h4 id="与-得区别"><a href="#与-得区别" class="headerlink" title="==与===得区别"></a>==与===得区别</h4><p>a===b </p>
<p>类型不同，返回false</p>
<p>类型相同：</p>
<p>​        null === null</p>
<p>​        nudefined === undefined</p>
<p>​        NaN &ne; NaN</p>
<p>a==b</p>
<p>类型相同，同===</p>
<p>类型不同，尝试类型转换和比较</p>
<p>null==undefined 相等</p>
<p>number==string转number   1==”1.0”//true 备注：尝试把字符串转换为数字</p>
<p>boolean==?转number 1==true //true</p>
<p>object== number | string 尝试对象转换为基本类型 new String(“hi”) ==”hi” // true </p>
<p>其他：false</p>
<h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h4><p><img src="https://s2.ax1x.com/2020/01/21/1FsU4H.jpg" alt="1FsU4H.jpg"></p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h4><pre><code class="lang-javascript">[1,2] instanceof Array === true
new Object() instanceof Array === false
</code></pre>
<h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a><code>Object.prototype.toString</code></h4><p><img src="https://s2.ax1x.com/2020/01/21/1Fsh2n.png" alt="1Fsh2n.png"></p>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h4><pre><code class="lang-javascript">var test=new Array();
if (test.constructor==Array)
{
    document.write(&quot;This is an Array&quot;);
}
</code></pre>
<h4 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a><code>Duck Typing</code></h4><p>鸭子类型（duck typing）如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。<br>只关注对象的行为，不关注对象本身面向接口编型 ，而不是面向实现编程，是设计模式中最重要的思想。</p>
<p><a href="https://blog.csdn.net/Donspeng/article/details/76079403" target="_blank" rel="noopener">原博主</a></p>
<p>应用场景：流程控制<br> 好处：去掉冗余的条件判断<br> 通过实例来说明：<br> 不使用Duck Typing：</p>
<pre><code class="lang-javascript">function bird(){
    this.name=&quot;bird&quot;;
}
function duck(){
    this.name=&quot;duck&quot;;
}
const type=(animal)=&gt;{
    if(animal instanceof bird){
        console.log(&quot;I am a bird&quot;);
    }else if(animal instanceof duck){
        console.log(&quot;I am a duck&quot;);
    }
}
var b=new bird();
var d=new duck();
type(b);
type(d);
</code></pre>
<p>使用Duck Typing：</p>
<pre><code class="lang-javascript"> var bird={
    name:&#39;bird&#39;,
    speak:function(){
        console.log(&quot;I am a &quot;+this.name);
    }
}
var duck={
    name:&quot;duck&quot;,
    speak:function(){
        console.log(&quot;I am a &quot;+this.name);
    }
}
const type=(animal)=&gt;{
    if(typeof animal.speak == &quot;function&quot;){
        animal.speak();
        return true;
    }
    return false;
}
type(bird);
type(duck);
</code></pre>
<p>大概的意思应该就是用Duck Typing 减少了一些条件判断   你只需要有speak方法，那就speak，不需要判断你的类型</p>
<p><img src="https://s2.ax1x.com/2020/01/21/1Fy4Fe.jpg" alt="1Fy4Fe.jpg"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JS创建数组的三种方法</title>
    <url>/2020/01/20/JS%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>因为最近在学JS所以就开始从一些简单得知识点看起吧~<br><a id="more"></a></p>
<h2 id="JS-创建数组的三种方法"><a href="#JS-创建数组的三种方法" class="headerlink" title="JS 创建数组的三种方法"></a>JS 创建数组的三种方法</h2><h3 id="1-隐形创建"><a href="#1-隐形创建" class="headerlink" title="1.隐形创建"></a>1.隐形创建</h3><pre><code class="lang-javascript">var arr = [&#39;Audi&#39;,&#39;Bmw&#39;,&#39;Volvo&#39;];
</code></pre>
<h3 id="2-直接实体化"><a href="#2-直接实体化" class="headerlink" title="2.直接实体化"></a>2.直接实体化</h3><pre><code class="lang-javascript">var arr = new Array(&#39;Audi&#39;,&#39;Bmw&#39;,&#39;Volvo&#39;);
</code></pre>
<h3 id="3-创建数组并给数组元素赋值"><a href="#3-创建数组并给数组元素赋值" class="headerlink" title="3.创建数组并给数组元素赋值"></a>3.创建数组并给数组元素赋值</h3><pre><code class="lang-javascript">var arr = new Array();
arr[0]=&#39;Audi&#39;;
arr[1]=&#39;Bmw&#39;;
arr[2]=&#39;Volvo&#39;;
</code></pre>
<h3 id="4-数组的属性"><a href="#4-数组的属性" class="headerlink" title="4.数组的属性"></a>4.数组的属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">push</td>
<td>向后部插入一个元素</td>
</tr>
<tr>
<td style="text-align:left">unshift</td>
<td>向头部插入一个元素</td>
</tr>
<tr>
<td style="text-align:left">delete</td>
<td>将某个数组内的元素赋值为undefined</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/jsref/jsref_constructor_array.asp" target="_blank" rel="noopener">constructor</a></td>
<td>返回创建对象的数组函数的引用。</td>
</tr>
<tr>
<td style="text-align:left">length</td>
<td>设置或返回数组中元素的数目。</td>
</tr>
<tr>
<td style="text-align:left">prototype</td>
<td>使你有能力想对象添加属性和方法。</td>
</tr>
</tbody>
</table>
</div>
<p>delete(arr[1]) : 将数组中第二个值复制为empty | undefined</p>
<p>arr.includes(5): 返回的是布尔值 true |  false  数组中是否存在5 </p>
<p>arr.indexOf(5): 返回索引值 不存在返回-1</p>
<p>关于显示定义和隐性定义的区别“</p>
<p>1.当在全局时，他们都是定义全局变量，只不过隐式定义相当于是给全局对象绑了一个新的属性，所以它本身就不想显示定义那样会有自己的属性和方法。</p>
<p>2.当在函数内定义时，显示定义的是<strong>局部变量</strong>，而隐式定义任然是给全局对象绑定一个新的属性，所以它相当于是定义成了没有自己的属性和方法的<strong>全局变量</strong>了。</p>
<p>3.5</p>
<p>最近一直被数组 对象 困惑 搞我的心态崩了 今天来总结一下数组在算法中常用的小技巧</p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>算法无非是由for循环构成的（口胡的</p>
<p>下面我们来看一下JS中如何循环数组或对象呢</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3HYvMF.png" alt="3HYvMF.png"></p>
<p>当我看到这个图的时候 我的内心是崩溃的。。。。我更加崩溃了 最后在前辈们的指点下 有点了解</p>
<p>数组遍历：forEach 或者 map 再讲讲这两者的区别吧</p>
<p>当你不需要改变数组的用forEach 当你需要改变数组的值得时候用map 并且map返回得是一个数组</p>
<p>当我们需要条件判断且需要退出循环的时候 只能用for了因为forEach 不会退出循环</p>
<pre><code class="lang-js">var arr=[1,2,3,4];  
arr.forEach((value,index)=&gt;{
    console.log(index);// index 数组序号 value 值 下面同理
})
// console.log(arr2);
arr.map((value)=&gt;value*2)
console.log(arr);
/* 2 4 6 8*/
</code></pre>
<p>for in 主要用于得就是对象 注意返回得是string类型</p>
<pre><code class="lang-js">var arr={
    1:&#39;2&#39;,
    2:&#39;3&#39;,
    3:&#39;4&#39;
}
for(var i in arr){
    console.log(i+1,arr[i]+1);
}
/*
11 21
21 31
31 41
*/
</code></pre>
<p>for of 用于Map</p>
<pre><code class="lang-js">var arr=new Map();
arr.set(1,1);
arr.set(2,2);
arr.set(3,3);
for(var [key,index] of arr){
    console.log(key,index);
}
/*
1 1
2 2
3 3
*/
</code></pre>
<p>JS中Map的用法</p>
<p>声明 </p>
<pre><code>var map = new Map();
</code></pre><p>设值</p>
<pre><code>map.set(&quot;key&quot;,&quot;value&quot;);
</code></pre><p>取值</p>
<pre><code>map.get(&quot;key&quot;);
</code></pre><p>判断key是否存在</p>
<pre><code>map.has(&quot;key&quot;);
</code></pre><p> 删除key</p>
<pre><code>map.delete(&quot;key&quot;);
</code></pre><p>想到map 之后 我又在想 js中又没栈和队列呢 ？ 好像是没有的不过没关系Array数组中有很多方法 我们可以实现模拟栈 </p>
<pre><code class="lang-js">var arr = [1, 2, 3, 4, 5];

arr.push(6); // 存入数据 arr -&gt; [1, 2, 3, 4, 5, 6]
arr.pop();   // 取出数据 arr -&gt; [1, 2, 3, 4, 5]
</code></pre>
<p>是不是一样的舒服 </p>
<p>队列Queue</p>
<pre><code class="lang-js">var arr = [1, 2, 3, 4, 5];

// 队尾in
arr.push(6);    // 存入 arr -&gt; [1, 2, 3, 4, 5, 6]
// 队头out
arr.shift();    // 取出 arr -&gt; [2, 3, 4, 5, 6]
</code></pre>
<h1 id="ES6引入新的数据类型Map和Set"><a href="#ES6引入新的数据类型Map和Set" class="headerlink" title="ES6引入新的数据类型Map和Set"></a>ES6引入新的数据类型Map和Set</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre><code class="lang-js">let oneSet = new Set();
console.log(&quot;创建map和set成功&quot;);

// 举例,如果我们想要知道小明的成绩是多少,我们就需要使用两个Array;一个用于存储姓名,一个用于存储对应的成绩;
var nameArray = [&#39;li&#39;, &#39;zhou&#39;, &#39;yang&#39;];
var scroeArray = [90, 98, 87];
// 如果人越多,Array越长,那么就要耗费更多的时间;但是使用Map,只要一个名称-成绩的对照表,直接根据名字查找,
// 无论这个表有多慢,查找都很快速.

// 初始化一个Map,需要一个二维数组
var exampleMap = new Map([
    [&#39;li&#39;, 90],
    [&#39;zhou&#39;, 98],
    [&#39;yang&#39;, 87]
]);
console.log(oneMap.get(&#39;yang&#39;)); // 结果是87

//我们也可以直接创建一个空Map,然后调用set方法进行添加元素
oneMap.set(&#39;li&#39;, 90);
oneMap.set(&#39;zhou&#39;, 98);
oneMap.set(&#39;yang&#39;, 87);
console.log(oneMap.get(&#39;yang&#39;)); // 结果是87

// has方法可以用来检测Map是否包含某个key对应的元素
var isHasLi = oneMap.has(&#39;li&#39;);
console.log(isHasLi); // 结果是true

var hasDelete = oneMap.delete(&#39;li&#39;);
console.log(&quot;删除&quot; + hasDelete); // 结果是 删除true

// 另外,因为一个key只能对应一个value,所以多次对一个key放入value,后面的值会覆盖前面的值
oneMap.set(&#39;niu&#39;, 89);
oneMap.set(&#39;niu&#39;, 99);
console.log(oneMap.get(&#39;niu&#39;)); // 结果是99
</code></pre>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><pre><code class="lang-js">// 下面来看set集合
// Set和Map类似,也是一组key的结合,但是不存储value,由于key不重复,所以Set中没有重复的plus.key
// 初始化set需要传入一个一维数组
var mySet = new Set([1, 2, 3]);
// 或使用add方法进行添加
var secondSet = new Set();
secondSet.add(&#39;li&#39;);
secondSet.add(&#39;niu&#39;);
// 注意添加相同的元素会自动去重
secondSet.add(&#39;li&#39;);
console.log(secondSet.size) //长度还是2
// delete(key)可以删除元素
secondSet.delete(&#39;li&#39;);
console.log(secondSet.size);
</code></pre>
<h2 id="两者的遍历方法"><a href="#两者的遍历方法" class="headerlink" title="两者的遍历方法"></a>两者的遍历方法</h2><pre><code class="lang-js">// 迭代器 iterable,可以用于Map Set和Array
// 具有iterabl类型的集合,可以通过新的for....of循环遍历,并且遍历得到的是value,而不是key
for (var x of oneMap) {
    console.log(x.toString());
    // zhou,98
    // yang,87
    // niu,99
}
// 对于map集合,我们可以获取key以及对应的value
for (var x of oneMap) {
    console.log(x[0] + &quot; &quot; + x[1]);
    // zhou 98
    // yang 87
    // niu 99
}
// 对于set集合
for (var x of secondSet) {
    console.log(x); // 结果是niu
}
</code></pre>
<h2 id="for-in-和for-of-的区别"><a href="#for-in-和for-of-的区别" class="headerlink" title="for..in 和for ..of 的区别"></a>for..in 和for ..of 的区别</h2><pre><code class="lang-js">// 下面来看下for..in和for...of的区别
// for..in实际上遍历的是对象的属性名称,对于数组Array来说,实际上也是对象,她的每个元素的索引都被视为属性
//;当我们手动给数组对象添加额外的属性时候,使用for..in就会带来意外的效果
var myArray = [1, 3, 5];
myArray.name = &#39;heihei&#39;;
for (var x in myArray) {
    console.log(x);
    // 结果是 0 1 2 name,这里把name也给遍历出来了;
}
// 但是使用for..of就不会出现这样的问题,他只循环集合本身的元素
for (var x of myArray) {
    console.log(x);
    // 结果是 1 3 5
}
</code></pre>
<pre><code class="lang-js">// forEach方法是iterable内置的方法,接收一个函数,每次迭代就自动回调该函数
myArray.forEach(function(element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    console.log(element + &#39;, index = &#39; + index);
});
// 对Map集合来说,第一个参数value,第二个参数是key;
oneMap.forEach(function(value,key,map){ 
    console.log(value + &#39;, key = &#39; + key);
});
// 对于set集合来说,因为没有索引,所以第一个第二个参数都是value
secondSet.forEach(function(value,sameValue,set){
    console.log(value + &#39;, sameValue = &#39; + sameValue);
});
// 另外,js函数调用不要求参数一致,所以如果我们只关心value,可以这么写
myArray.forEach(function(element){
    console.log(element);
    //结果是 1 3 5 
})
</code></pre>
<p>大写字母A-Z对应的ASCII码值是65-90</p>
<p>小写字母a-z对应的ASCII码值是97-122</p>
<p>将字母转为ascii嘛的方法：</p>
<pre><code class="lang-javascript">var str = &quot;A&quot;;
str.charCodeAt();  // 65

var str1 = &#39;a&#39;;
str1.charCodeAt();  // 97

var num = 97;
String.fromCharCode(num);  // &#39;a&#39;

var num1 = 100;
String.fromCharCode(num1);  // &#39;d&#39;
</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程（一）：封装</title>
    <url>/2020/01/19/Javascript%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>学习Javascript，最难的地方是什么？我觉得，Object（对象）最难。因为Javascript的Object模型很独特，和其他语言都不一样，初学者不容易掌握。下面就是我的学习笔记，希望对大家学习这个部分有所帮助。</p>
<a id="more"></a>
<h2 id="一、生成实例对象的原始模式"><a href="#一、生成实例对象的原始模式" class="headerlink" title="一、生成实例对象的原始模式"></a>一、生成实例对象的原始模式</h2><p>假定我们把猫看成一个对象</p>
<pre><code class="lang-javascript">Var cat ={
        name : &#39;&#39;,
        color : &#39;&#39;
}
</code></pre>
<p>然后，我们需要根据这个原型对象的规格，生成两个实体对象。</p>
<pre><code class="lang-javascript">var cat1 ={};
    cat1.name=&quot;大毛&quot;; // 按照原型对象的属性复制
    cat1.color=&quot;黄色&quot;;
var cat2 ={};
    cat2.name=&quot;二毛&quot;;
    cat2.color=&quot;黑色&quot;;
</code></pre>
<p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>
<h2 id="二、原始模式的改进"><a href="#二、原始模式的改进" class="headerlink" title="二、原始模式的改进"></a>二、原始模式的改进</h2><p>我们可以写一个函数，解决代码重复问题。</p>
<pre><code class="lang-javascript">function cat(name,color){
    return {
        name:name;
        color:color;
    }
}
</code></pre>
<p>然后生成实例对象，就等于是再调用函数：</p>
<pre><code class="lang-javascript">var cat1=cat(&quot;大毛&quot;,&quot;黄色&quot;);
var cat2=cat(&quot;二毛&quot;,&quot;黑色&quot;);
</code></pre>
<p>这种方法的问题依然是，<code>cat1</code>和<code>cat2</code>之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h2 id="三、构造函数模式"><a href="#三、构造函数模式" class="headerlink" title="三、构造函数模式"></a>三、构造函数模式</h2><p>为了解决从原型对象生成实例的问题，<code>Javascript</code>提供了一个构造函数（Constructor）模式。</p>
<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用<code>new</code>运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上。 </p>
<p>比如，猫的原型对象现在可以这样写：</p>
<pre><code class="lang-javascript">function cat (name,color){
    this.name=name;
    this.color=color;
}

var cat1=new cat(&quot;大毛&quot;,&quot;黄色&quot;);
var cat2=new cat(&quot;二毛&quot;,&quot;黑色&quot;);
alert(cat1.name); // 大猫
alert(cat2.color); // 黄色
</code></pre>
<p>这时<code>cat1</code>和<code>cat2</code>会自动含有一个<code>constructor</code>属性，指向它们的构造函数。</p>
<p>同时<code>Javascript</code>还提供了一个 <code>instanceof</code> 运算符</p>
<pre><code class="lang-javascript">alert(cat1.constructor == cat); // true
alert(cat2.constructor == cat); // true

alert(cat1 instanceof cat); //true
alert(cat2 instanceof cat); //true
</code></pre>
<h2 id="四、构造函数模式的问题"><a href="#四、构造函数模式的问题" class="headerlink" title="四、构造函数模式的问题"></a>四、构造函数模式的问题</h2><p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>
<p>请看，我们现在为<code>cat</code>对象添加一个不变的属性<code>type</code>（种类），在添加一个方法<code>eat</code>（吃）。那么，原型对象<code>cat</code>就变成了下面这样：</p>
<pre><code class="lang-javascript">function cat(name,color){
    this.name=name;
    this.color=color;
    this.type=&quot;猫科动物&quot;;
    this.eat=function(){alert(&quot;吃老鼠&quot;);};
}

// 还是采用同样的方法，生成实例：
var cat1=new cat(&quot;大毛&quot;,&quot;黄色&quot;);
var cat2=new cat(&quot;二毛&quot;,&quot;黑色&quot;);
alert(cat1.type); // 猫科动物
cat1.eat(); // 吃老鼠

alert(cat1.eat == cat2.eat); //false
</code></pre>
<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，<code>type</code>属性和<code>eat()</code>方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>
<h2 id="五、Prototype模式"><a href="#五、Prototype模式" class="headerlink" title="五、Prototype模式"></a>五、Prototype模式</h2><p><code>Javascript</code>规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在<code>prototype</code>对象上。</p>
<pre><code class="lang-javascript">function cat(name,color){
    this.name=name;
    this.color=color;
}
cat.prototype.type=&quot;猫科动物&quot;;
cat.prototype.eat=function(){alert(&quot;吃老鼠&quot;)};

//生成实例
var cat1 = new cat(&quot;大毛&quot;,&quot;黄色&quot;);
var cat2 = new cat(&quot;二毛&quot;,&quot;黑色&quot;);
alert(cat1.type); // 猫科动物
cat1.eat(); // 吃老鼠
</code></pre>
<p>这时所有实例的<code>type</code>属性和<code>eat()</code>方法，其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p>
<h2 id="六、Prototype模式的验证方法"><a href="#六、Prototype模式的验证方法" class="headerlink" title="六、Prototype模式的验证方法"></a>六、Prototype模式的验证方法</h2><p>为了配合<code>prototype</code>属性，<code>Javascript</code>定义了一些辅助方法，帮助我们使用它。</p>
<h3 id="6-1-isPrototypeOf"><a href="#6-1-isPrototypeOf" class="headerlink" title="6.1 isPrototypeOf()"></a>6.1 <code>isPrototypeOf()</code></h3><p>这种方法用来判断，某个<code>prototype</code>对象和某个实例之间的关系。</p>
<pre><code class="lang-javascript">alert(cat.prototype.isPrototypeOf(cat1)); // true
alert(cat.prototype.isPrototypeOf(cat2)); // true
</code></pre>
<h3 id="6-2-hasOwnProperty"><a href="#6-2-hasOwnProperty" class="headerlink" title="6.2 hasOwnProperty()"></a>6.2 <code>hasOwnProperty()</code></h3><p>每个实例对象都有一个<code>hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性。</p>
<pre><code class="lang-javascript">alert(cat1.hasOwnProperty(&quot;name&quot;)); //true
alert(cat1.hasOwnproperty(&quot;type&quot;)); //false
</code></pre>
<h1 id="6-3-in运算符"><a href="#6-3-in运算符" class="headerlink" title="6.3 in运算符"></a>6.3 <code>in</code>运算符</h1><p><code>in</code>运算发可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<pre><code class="lang-javascript">alert(&quot;name&quot; in cat1); // true
alert(&quot;type&quot; in cat1); // true
</code></pre>
<p>in 运算符还可以用来遍历某个对象的所以属性。</p>
<pre><code class="lang-javascript">for(var prop in cat1){
    alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]);}
</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序学习</title>
    <url>/2020/01/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>小程序学习<br><a id="more"></a></p>
<h1 id="获取目前所处位置"><a href="#获取目前所处位置" class="headerlink" title="获取目前所处位置"></a>获取目前所处位置</h1><p><img src="https://i.loli.net/2020/01/18/tvjCBleVqTi3brK.jpg" alt="162538-15586863381bcc.jpg"></p>
<pre><code class="lang-javascript">onShow(){
    var that=this;
    wx.getLocation({
      type: &#39;wgs84&#39;,
      success(res) {
        const latitude1 = res.latitude;
        const longitude1 = res.longitude;
        const speed1 = res.speed;
        const accuracy1 = res.accuracy;
        that.setData({
          longitude: res.longitude,
          latitude: res.latitude
        })
      }
    })
  },
</code></pre>
<pre><code class="lang-javascript">onShow(){
    this.getLocation(this);
  },
  getLocation()
  {
    wx.getLocation({
        type: &#39;wgs84&#39;,
        success: this.handleGetLocationSucc.bind(this)
    })
  },
  handleGetLocationSucc(res)
  {
    this.setData({
    longitude: res.longitude,
    latitude: res.latitude
    })
  },
</code></pre>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
</search>
