<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS对象</title>
    <url>/2020/01/21/JS%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>关于JS对象的一些属性<br><a id="more"></a></p>
<h2 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h2><h3 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h3><pre><code class="lang-javascript">var man={
    name:&#39;Bosn&#39;,
    weibo:&#39;@Bosn&#39;,
    get age(){
        return new Date().getFullYear()-1995;
    },
    set age(val){
    console.log(&#39;等式右边是&#39;+val);
    }
}
console.log(man.age);//24，读get的属性
man.age=100;//等式右边是100，等式右边的值会传给set属性的形参val
console.log(man.age);//still 24,因为读的是get的age属性,并没有被改变
</code></pre>
<p>注意：get的属性不能被赋值！</p>
<h3 id="get-set与原型链"><a href="#get-set与原型链" class="headerlink" title="get/set与原型链"></a>get/set与原型链</h3><p><code>ps</code>:读取属性是自下而上寻找原型链</p>
<p>如果对象的原型上有一个属性，且这个属性是get法定义，则不能用<code>obj.property</code>的方式给当前对象添加同样名字的新属性。比如：</p>
<pre><code class="lang-javascript">function foo(){
    Object.defineProperty(foo.prototype,&#39;z&#39;,{get:function(){rerurn1;}});
｝
var obj =new foo();
obj.z;//1
obj.z=10;//没有以给当前对象obj添加新属性的方式形成属性
obj.z;//still 1
</code></pre>
<p>可以用<code>obj.defineProperty(obj,&#39;z&#39;,{value:10,configurable:true});</code>法实现添加属性</p>
<p>看到这里是不是有人会想 如何在<code>Javascript</code>中通过实例对象修改对象的属性值呢</p>
<p>让我们来看看<a href="https://www.cnblogs.com/fogwind/p/5750764.html" target="_blank" rel="noopener">大佬</a>怎么写的</p>
<h4 id="JS中通过实例对象修改对象的属性值问题"><a href="#JS中通过实例对象修改对象的属性值问题" class="headerlink" title="JS中通过实例对象修改对象的属性值问题"></a>JS中通过实例对象修改对象的属性值问题</h4><p><code>Javascript</code>中的数据值有两大类：基本类型的数据值和引用类型的数据值。</p>
<p>基本类型的数据值有5种：null、undefined、number、boolean和string。</p>
<p>引用类型的数据值往大的说就1种，即<code>Object</code>类型。往细的说有：<code>Object</code>类型、<code>Array</code>类型、<code>Date</code>类型、<code>Regexp</code>类型、<code>Function</code>类型等。</p>
<p><strong>当原型对象的属性值为基本类型的数据值时，通过实例对象修改属性值从而引起原型对象的属性值发生变化的情况不会发生。当原型对象的属性值为引用类型的数据值时，通过实例对象修改属性值就可能引起原型对象的属性值发生变化。下面举例说明。</strong></p>
<p>例1：</p>
<pre><code class="lang-javascript">function Animal() {}
Animal.prototype = {
 constructor: Animal,// constructor 保存了指向 function 的一个引用
 number: &quot;very much&quot;,
 fish: [&quot;shark&quot;,&quot;sardine&quot;],
 bird:{
     ability: &quot;fly&quot;,
     feature: &quot;feather&quot;
 }
};
var animal1 = new Animal();
var animal2 = new Animal();
//没有改变原型的number属性,而是自己获得了number属性
animal1.number = 1000;
console.log(animal2.number);//very much
</code></pre>
<p>上例中通过构造函数Animal创建了两个实例对象，两个实例对象继承了同一个原型对象的属性。通过实例对象animal1重新设置了number属性，结果是实例对象animal1拥有了自己的number属性，没有改变原型对象的number属性值，实例对象animal2调用的number属性还是原型对象原来的number属性。</p>
<p>例2：</p>
<pre><code class="lang-javascript">function Animal() {}
Animal.prototype = {
 constructor: Animal,
 number: &quot;very much&quot;,
 fish: [&quot;shark&quot;,&quot;sardine&quot;],
 bird:{
     ability: &quot;fly&quot;,
     feature: &quot;feather&quot;
 }
};
var animal1 = new Animal();
var animal2 = new Animal();
var animal3 = new Animal();
//没有改写原型中的fish属性,此时animal1实例对象中有了自己的fish属性，向其自己的fish属性中推入和弹出项不会改变原型的fish属性。
animal1.fish = [&quot;cold fish&quot;];
for (var i=0;i&lt;animal2.fish.length;i++) {
  console.log(animal2.fish[i]);//shark,sardine,没有cold fish
 }
//通过实例对象animal3向fish属性中推入项，改变了原型对象的fish属性，因为实例对象中没有自己的fish属性
animal3.fish.push(&quot;voladao&quot;);
animal3.fish[0] = &quot;fly fish&quot;;
for (var i=0;i&lt;animal2.fish.length;i++) {
  console.log(animal2.fish[i]);//fly fish,sardine,voladao
 }
</code></pre>
<p>例2中实例对象animal1创建了自己的fish属性，没有改变原型对象的fish属性，所以实例对象animal2输出的还是原型对象的fish属性。</p>
<p>实例对象animal3没有自己的fish属性，但通过实例对象animal3向fish属性中推入了一项，并且改变了其中的第一项的值，这些改变都发生在了原型对象的fish属性上，所以实例对象animal2调用fish属性时，其属性值发生了变化。</p>
<p>例3：</p>
<pre><code class="lang-javascript">function Animal() {}
Animal.prototype = {
 constructor: Animal,
 number: &quot;very much&quot;,
 fish: [&quot;shark&quot;,&quot;sardine&quot;],
 bird:{
     ability: &quot;fly&quot;,
     feature: &quot;feather&quot;
 }
}
var animal1 = new Animal();
var animal2 = new Animal();
var animal3 = new Animal();
var animal4 = new Animal();
var animal5 = new Animal();
//改写了原型中的bird属性
animal1.bird.ability = &quot;run&quot;;
console.log(animal2.bird.ability);//run
//创建animal3的bird属性，没有改变原型对象的bird属性
 animal3.bird = {
   eat: &quot;fish&quot;
 };
 console.log(animal4.bird.eat);//undifined
 console.log(animal3.bird.eat);//fish
 animal5.bird.home = &quot;tree&quot;;
 console.log(animal4.bird.home);//tree
</code></pre>
<p>例3中通过实例对象animal1修改了bird属性的ability属性的值，实例对象animal1没有自己的bird属性，这个修改反映在了原型对象的bird属性上，实例对象animal2输出的bird.ability的值是改变后的值。</p>
<p>实例对象animal3创建了自己的bird属性，这没有改变原型对象的bird属性，所以实例对象4的bird.eat的值为undifined。</p>
<p>通过实例对象animal5添加了bird属性的home属性，实例对象animal5没有自己的bird属性，这个home属性添加到了原型对象的bird属性上，所以animal4的bird.home的值为tree。</p>
<h4 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h4><p>Configurable,Enumerable,Writable,Value</p>
<pre><code class="lang-javascript">var person = {}
Object.defineProperty(person,&#39;name&#39;,{
    configurable:false,//能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true
    enumerable:false,//对象属性是否可通过for-in循环，flase为不可循环，默认值为true
    writable:false,//对象属性是否可修改,flase为不可修改，默认值为true
    value:&#39;xiaoming&#39; //对象属性的默认值，默认值为undefined
});

//value
console.log(person);//xiaoming，默认value

//writable
person.name=&quot;qiang&quot;;
console.log(person);//xiaoming，不可修改value

//enumerable
for(var i in person){
    console.log(person[i]) //无结果，不可循环
}

//configurable
delete person.name
console.log(person.name)//xiaoming，不可删除

Object.defineProperty(person,&#39;name&#39;,{
    configurable:true //不可修改，将抛出错误
});
</code></pre>
<p><img src="https://s2.ax1x.com/2020/01/21/1kJCRS.jpg" alt="1kJCRS.jpg"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型判断</title>
    <url>/2020/01/20/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>关于数据类型判断的一道编程题<br><a id="more"></a><br><strong>本习题将验证你是否已经熟练掌握了数据类型知识。记得看完视频讲解，也要结合看书更全面的学习知识哦！</strong></p>
<pre><code>温馨提示:完成任务后，请验证结果窗口显示是否是&quot;判定结果:通过&quot;,如是恭喜您，你已经掌握此技能，否则，建议重复学习此内容。
</code></pre><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>请在index.html文件中，编写arraysSimilar函数，实现判断传入的两个数组是否相似。具体需求：</p>
<ol>
<li><p>数组中的成员类型相同，顺序可以不同。例如[1, true] 与 [false, 2]是相似的。</p>
</li>
<li><p>数组的长度一致。</p>
</li>
<li><p>类型的判断范围，需要区分:String, Boolean, Number, undefined, null, 函数，日期, window.</p>
</li>
</ol>
<p>当以上全部满足，则返回”判定结果:通过”，否则返回”判定结果:不通过”。// 网站判断功能失效了</p>
<p><a href="https://www.imooc.com/code/5760" target="_blank" rel="noopener">题目链接</a></p>
<pre><code class="lang-javascript">function arraysSimilar(arr1, arr2){
            if(!(arr1 instanceof Array)||!(arr2 instanceof Array))
            {
                return false;
            }
            if(arr1.length!=arr2.length)
            return false;
            var n = arr1.length,
                countMap1 = {},
                countMap2 = {},
                t1,t2,
                TYPES=[&#39;string&#39;,&#39;boolean&#39;,&#39;number&#39;,&#39;undefined&#39;,&#39;null&#39;,&#39;function&#39;,&#39;data&#39;,&#39;window&#39;];
            for(var i=0;i&lt;n;i++)
            {
                t1=typeof(arr1[i]);
                t2=typeof(arr2[i]);
                if(countMap1[t1])
                {
                    countMap1[t1]++;
                }
                else
                countMap1[t1]=1;

                if(countMap2[t2])
                {
                    countMap2[t2]++;
                }
                else
                countMap2[t2]=1;
            }
            function typeof(value)
            {
                var r;
                if (value==null)
                r=&#39;null&#39;;
                else if (value instanceof Array)
                r=&#39;array&#39;;
                else if(value === window)
                r=&#39;window&#39;;
                else if(value instanceof Date)
                r=&#39;data&#39;;
                else r= typeof value;
                return r;
            }
            for(var i=0,n=TYPES.length;i&lt;n;i++)
            {
                if(countMap1[TYPES[i]]!=countMap2[TYPES[i]])
                retunr false;
            }
            return true;
        }
</code></pre>
<p>数据：</p>
<pre><code class="lang-javascript">var result=function(){
    //以下为多组测试数据
            var cases=[{
                    arr1:[1,true,null],
                    arr2:[null,false,100],
                    expect:true
                },{
                    arr1:[function(){},100],
                    arr2:[100,{}],
                    expect:false
                },{
                    arr1:[null,999],
                    arr2:[{},444],
                    expect:false
                },{
                    arr1:[window,1,true,new Date(),&quot;hahaha&quot;,(function(){}),undefined],
                    arr2:[undefined,(function(){}),&quot;okokok&quot;,new Date(),false,2,window],
                    expect:true
                },{
                    arr1:[new Date()],
                    arr2:[{}],
                    expect:false
                },{
                    arr1:[window],
                    arr2:[{}],
                    expect:false
                },{
                    arr1:[undefined,1],
                    arr2:[null,2],
                    expect:false
                },{
                    arr1:[new Object,new Object,new Object],
                    arr2:[{},{},null],
                    expect:false
                },{
                    arr1:null,
                    arr2:null,
                    expect:false
                },{
                    arr1:[],
                    arr2:undefined,
                    expect:false
                },{
                    arr1:&quot;abc&quot;,
                    arr2:&quot;cba&quot;,
                    expect:false
                }];

    //使用for循环, 通过arraysSimilar函数验证以上数据是否相似，如相似显示“通过”,否则&quot;不通过&quot;,所以大家要完成arraysSimilar函数,具体要求，详见任务要求。    
            for(var i=0;i&lt;cases.length;i++){
                if(arraysSimilar(cases[i].arr1,cases[i].arr2)!==cases[i].expect) {
                    document.write(&quot;不通过！case&quot;+(i+1)+&quot;不正确！arr1=&quot;+JSON.stringify(cases[i].arr1)+&quot;, arr2=&quot;+JSON.stringify(cases[i].arr2)+&quot; 的判断结果不是&quot;+cases[i].expect);
                    return false;
                }                
            }
            return true;

        }();
    document.write(&quot;判定结果:&quot;+(result?&quot;通过&quot;:&quot;不通过&quot;));
</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数据类型</title>
    <url>/2020/01/20/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>关于JS的6中数据类型<br><a id="more"></a></p>
<h1 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h1><h3 id="1-六种数据类型"><a href="#1-六种数据类型" class="headerlink" title="1.六种数据类型"></a>1.六种数据类型</h3><p><img src="https://s2.ax1x.com/2020/01/21/1FBhgx.png" alt="1FBhgx.png"></p>
<h3 id="2-隐式转换"><a href="#2-隐式转换" class="headerlink" title="2.隐式转换"></a>2.隐式转换</h3><h4 id="隐式转换逻辑：字符串-数字，默认字符串相加；字符串-数字，会先把字符串隐式转换成数字再计算。巧用隐式转换可以将字符串和数字类型相互转换；如图-0或-‘’"><a href="#隐式转换逻辑：字符串-数字，默认字符串相加；字符串-数字，会先把字符串隐式转换成数字再计算。巧用隐式转换可以将字符串和数字类型相互转换；如图-0或-‘’" class="headerlink" title="隐式转换逻辑：字符串+数字，默认字符串相加；字符串-数字，会先把字符串隐式转换成数字再计算。巧用隐式转换可以将字符串和数字类型相互转换；如图-0或+‘’"></a>隐式转换逻辑：字符串+数字，默认字符串相加；字符串-数字，会先把字符串隐式转换成数字再计算。巧用隐式转换可以将字符串和数字类型相互转换；如图-0或+‘’</h4><p><img src="https://s2.ax1x.com/2020/01/21/1FBj2t.jpg" alt="1FBj2t.jpg"></p>
<h4 id="与-得区别"><a href="#与-得区别" class="headerlink" title="==与===得区别"></a>==与===得区别</h4><p>a===b </p>
<p>类型不同，返回false</p>
<p>类型相同：</p>
<p>​        null === null</p>
<p>​        nudefined === undefined</p>
<p>​        NaN &ne; NaN</p>
<p>a==b</p>
<p>类型相同，同===</p>
<p>类型不同，尝试类型转换和比较</p>
<p>null==undefined 相等</p>
<p>number==string转number   1==”1.0”//true 备注：尝试把字符串转换为数字</p>
<p>boolean==?转number 1==true //true</p>
<p>object== number | string 尝试对象转换为基本类型 new String(“hi”) ==”hi” // true </p>
<p>其他：false</p>
<h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h4><p><img src="https://s2.ax1x.com/2020/01/21/1FsU4H.jpg" alt="1FsU4H.jpg"></p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h4><pre><code class="lang-javascript">[1,2] instanceof Array === true
new Object() instanceof Array === false
</code></pre>
<h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a><code>Object.prototype.toString</code></h4><p><img src="https://s2.ax1x.com/2020/01/21/1Fsh2n.png" alt="1Fsh2n.png"></p>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h4><pre><code class="lang-javascript">var test=new Array();
if (test.constructor==Array)
{
    document.write(&quot;This is an Array&quot;);
}
</code></pre>
<h4 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a><code>Duck Typing</code></h4><p>鸭子类型（duck typing）如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。<br>只关注对象的行为，不关注对象本身面向接口编型 ，而不是面向实现编程，是设计模式中最重要的思想。</p>
<p><a href="https://blog.csdn.net/Donspeng/article/details/76079403" target="_blank" rel="noopener">原博主</a></p>
<p>应用场景：流程控制<br> 好处：去掉冗余的条件判断<br> 通过实例来说明：<br> 不使用Duck Typing：</p>
<pre><code class="lang-javascript">function bird(){
    this.name=&quot;bird&quot;;
}
function duck(){
    this.name=&quot;duck&quot;;
}
const type=(animal)=&gt;{
    if(animal instanceof bird){
        console.log(&quot;I am a bird&quot;);
    }else if(animal instanceof duck){
        console.log(&quot;I am a duck&quot;);
    }
}
var b=new bird();
var d=new duck();
type(b);
type(d);
</code></pre>
<p>使用Duck Typing：</p>
<pre><code class="lang-javascript"> var bird={
    name:&#39;bird&#39;,
    speak:function(){
        console.log(&quot;I am a &quot;+this.name);
    }
}
var duck={
    name:&quot;duck&quot;,
    speak:function(){
        console.log(&quot;I am a &quot;+this.name);
    }
}
const type=(animal)=&gt;{
    if(typeof animal.speak == &quot;function&quot;){
        animal.speak();
        return true;
    }
    return false;
}
type(bird);
type(duck);
</code></pre>
<p>大概的意思应该就是用Duck Typing 减少了一些条件判断   你只需要有speak方法，那就speak，不需要判断你的类型</p>
<p><img src="https://s2.ax1x.com/2020/01/21/1Fy4Fe.jpg" alt="1Fy4Fe.jpg"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JS创建数组的三种方法</title>
    <url>/2020/01/20/JS%20%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>因为最近在学JS所以就开始从一些简单得知识点看起吧~<br><a id="more"></a></p>
<h2 id="JS-创建数组的三种方法"><a href="#JS-创建数组的三种方法" class="headerlink" title="JS 创建数组的三种方法"></a>JS 创建数组的三种方法</h2><h3 id="1-隐形创建"><a href="#1-隐形创建" class="headerlink" title="1.隐形创建"></a>1.隐形创建</h3><pre><code class="lang-javascript">var arr = [&#39;Audi&#39;,&#39;Bmw&#39;,&#39;Volvo&#39;];
</code></pre>
<h3 id="2-直接实体化"><a href="#2-直接实体化" class="headerlink" title="2.直接实体化"></a>2.直接实体化</h3><pre><code class="lang-javascript">var arr = new Array(&#39;Audi&#39;,&#39;Bmw&#39;,&#39;Volvo&#39;);
</code></pre>
<h3 id="3-创建数组并给数组元素赋值"><a href="#3-创建数组并给数组元素赋值" class="headerlink" title="3.创建数组并给数组元素赋值"></a>3.创建数组并给数组元素赋值</h3><pre><code class="lang-javascript">var arr = new Array();
arr[0]=&#39;Audi&#39;;
arr[1]=&#39;Bmw&#39;;
arr[2]=&#39;Volvo&#39;;
</code></pre>
<h3 id="4-数组的属性"><a href="#4-数组的属性" class="headerlink" title="4.数组的属性"></a>4.数组的属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/jsref/jsref_constructor_array.asp" target="_blank" rel="noopener">constructor</a></td>
<td>返回创建对象的数组函数的引用。</td>
</tr>
<tr>
<td style="text-align:left">length</td>
<td>设置或返回数组中元素的数目。</td>
</tr>
<tr>
<td style="text-align:left">prototype</td>
<td>使你有能力想对象添加属性和方法。</td>
</tr>
</tbody>
</table>
</div>
<p>关于显示定义和隐性定义的区别“</p>
<p>1.当在全局时，他们都是定义全局变量，只不过隐式定义相当于是给全局对象绑了一个新的属性，所以它本身就不想显示定义那样会有自己的属性和方法。</p>
<p>2.当在函数内定义时，显示定义的是<strong>局部变量</strong>，而隐式定义任然是给全局对象绑定一个新的属性，所以它相当于是定义成了没有自己的属性和方法的<strong>全局变量</strong>了。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程（一）：封装</title>
    <url>/2020/01/19/2020-01-19-1/</url>
    <content><![CDATA[<p>学习Javascript，最难的地方是什么？我觉得，Object（对象）最难。因为Javascript的Object模型很独特，和其他语言都不一样，初学者不容易掌握。下面就是我的学习笔记，希望对大家学习这个部分有所帮助。</p>
<a id="more"></a>
<h2 id="一、生成实例对象的原始模式"><a href="#一、生成实例对象的原始模式" class="headerlink" title="一、生成实例对象的原始模式"></a>一、生成实例对象的原始模式</h2><p>假定我们把猫看成一个对象</p>
<pre><code class="lang-javascript">Var cat ={
        name : &#39;&#39;,
        color : &#39;&#39;
}
</code></pre>
<p>然后，我们需要根据这个原型对象的规格，生成两个实体对象。</p>
<pre><code class="lang-javascript">var cat1 ={};
    cat1.name=&quot;大毛&quot;; // 按照原型对象的属性复制
    cat1.color=&quot;黄色&quot;;
var cat2 ={};
    cat2.name=&quot;二毛&quot;;
    cat2.color=&quot;黑色&quot;;
</code></pre>
<p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>
<h2 id="二、原始模式的改进"><a href="#二、原始模式的改进" class="headerlink" title="二、原始模式的改进"></a>二、原始模式的改进</h2><p>我们可以写一个函数，解决代码重复问题。</p>
<pre><code class="lang-javascript">function cat(name,color){
    return {
        name:name;
        color:color;
    }
}
</code></pre>
<p>然后生成实例对象，就等于是再调用函数：</p>
<pre><code class="lang-javascript">var cat1=cat(&quot;大毛&quot;,&quot;黄色&quot;);
var cat2=cat(&quot;二毛&quot;,&quot;黑色&quot;);
</code></pre>
<p>这种方法的问题依然是，<code>cat1</code>和<code>cat2</code>之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h2 id="三、构造函数模式"><a href="#三、构造函数模式" class="headerlink" title="三、构造函数模式"></a>三、构造函数模式</h2><p>为了解决从原型对象生成实例的问题，<code>Javascript</code>提供了一个构造函数（Constructor）模式。</p>
<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用<code>new</code>运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上。 </p>
<p>比如，猫的原型对象现在可以这样写：</p>
<pre><code class="lang-javascript">function cat (name,color){
    this.name=name;
    this.color=color;
}

var cat1=new cat(&quot;大毛&quot;,&quot;黄色&quot;);
var cat2=new cat(&quot;二毛&quot;,&quot;黑色&quot;);
alert(cat1.name); // 大猫
alert(cat2.color); // 黄色
</code></pre>
<p>这时<code>cat1</code>和<code>cat2</code>会自动含有一个<code>constructor</code>属性，指向它们的构造函数。</p>
<p>同时<code>Javascript</code>还提供了一个 <code>instanceof</code> 运算符</p>
<pre><code class="lang-javascript">alert(cat1.constructor == cat); // true
alert(cat2.constructor == cat); // true

alert(cat1 instanceof cat); //true
alert(cat2 instanceof cat); //true
</code></pre>
<h2 id="四、构造函数模式的问题"><a href="#四、构造函数模式的问题" class="headerlink" title="四、构造函数模式的问题"></a>四、构造函数模式的问题</h2><p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>
<p>请看，我们现在为<code>cat</code>对象添加一个不变的属性<code>type</code>（种类），在添加一个方法<code>eat</code>（吃）。那么，原型对象<code>cat</code>就变成了下面这样：</p>
<pre><code class="lang-javascript">function cat(name,color){
    this.name=name;
    this.color=color;
    this.type=&quot;猫科动物&quot;;
    this.eat=function(){alert(&quot;吃老鼠&quot;);};
}

// 还是采用同样的方法，生成实例：
var cat1=new cat(&quot;大毛&quot;,&quot;黄色&quot;);
var cat2=new cat(&quot;二毛&quot;,&quot;黑色&quot;);
alert(cat1.type); // 猫科动物
cat1.eat(); // 吃老鼠

alert(cat1.eat == cat2.eat); //false
</code></pre>
<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，<code>type</code>属性和<code>eat()</code>方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>
<h2 id="五、Prototype模式"><a href="#五、Prototype模式" class="headerlink" title="五、Prototype模式"></a>五、Prototype模式</h2><p><code>Javascript</code>规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在<code>prototype</code>对象上。</p>
<pre><code class="lang-javascript">function cat(name,color){
    this.name=name;
    this.color=color;
}
cat.prototype.type=&quot;猫科动物&quot;;
cat.prototype.eat=function(){alert(&quot;吃老鼠&quot;)};

//生成实例
var cat1 = new cat(&quot;大毛&quot;,&quot;黄色&quot;);
var cat2 = new cat(&quot;二毛&quot;,&quot;黑色&quot;);
alert(cat1.type); // 猫科动物
cat1.eat(); // 吃老鼠
</code></pre>
<p>这时所有实例的<code>type</code>属性和<code>eat()</code>方法，其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p>
<h2 id="六、Prototype模式的验证方法"><a href="#六、Prototype模式的验证方法" class="headerlink" title="六、Prototype模式的验证方法"></a>六、Prototype模式的验证方法</h2><p>为了配合<code>prototype</code>属性，<code>Javascript</code>定义了一些辅助方法，帮助我们使用它。</p>
<h3 id="6-1-isPrototypeOf"><a href="#6-1-isPrototypeOf" class="headerlink" title="6.1 isPrototypeOf()"></a>6.1 <code>isPrototypeOf()</code></h3><p>这种方法用来判断，某个<code>prototype</code>对象和某个实例之间的关系。</p>
<pre><code class="lang-javascript">alert(cat.prototype.isPrototypeOf(cat1)); // true
alert(cat.prototype.isPrototypeOf(cat2)); // true
</code></pre>
<h3 id="6-2-hasOwnProperty"><a href="#6-2-hasOwnProperty" class="headerlink" title="6.2 hasOwnProperty()"></a>6.2 <code>hasOwnProperty()</code></h3><p>每个实例对象都有一个<code>hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性。</p>
<pre><code class="lang-javascript">alert(cat1.hasOwnProperty(&quot;name&quot;)); //true
alert(cat1.hasOwnproperty(&quot;type&quot;)); //false
</code></pre>
<h1 id="6-3-in运算符"><a href="#6-3-in运算符" class="headerlink" title="6.3 in运算符"></a>6.3 <code>in</code>运算符</h1><p><code>in</code>运算发可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<pre><code class="lang-javascript">alert(&quot;name&quot; in cat1); // true
alert(&quot;type&quot; in cat1); // true
</code></pre>
<p>in 运算符还可以用来遍历某个对象的所以属性。</p>
<pre><code class="lang-javascript">for(var prop in cat1){
    alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]);}
</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序学习</title>
    <url>/2020/01/16/2020-01-16-1/</url>
    <content><![CDATA[<p>小程序学习<br><a id="more"></a></p>
<h1 id="获取目前所处位置"><a href="#获取目前所处位置" class="headerlink" title="获取目前所处位置"></a>获取目前所处位置</h1><p><img src="https://i.loli.net/2020/01/18/tvjCBleVqTi3brK.jpg" alt="162538-15586863381bcc.jpg"></p>
<pre><code class="lang-javascript">onShow(){
    var that=this;
    wx.getLocation({
      type: &#39;wgs84&#39;,
      success(res) {
        const latitude1 = res.latitude;
        const longitude1 = res.longitude;
        const speed1 = res.speed;
        const accuracy1 = res.accuracy;
        that.setData({
          longitude: res.longitude,
          latitude: res.latitude
        })
      }
    })
  },
</code></pre>
<pre><code class="lang-javascript">onShow(){
    this.getLocation(this);
  },
  getLocation()
  {
    wx.getLocation({
        type: &#39;wgs84&#39;,
        success: this.handleGetLocationSucc.bind(this)
    })
  },
  handleGetLocationSucc(res)
  {
    this.setData({
    longitude: res.longitude,
    latitude: res.latitude
    })
  },
</code></pre>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
</search>
